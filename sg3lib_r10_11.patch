diff --git a/ChangeLog b/ChangeLog
index 197873c..b956922 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -5,6 +5,10 @@ the source for the utilities. It is provided so that packages
 using the library from sg3_utils (e.g. sdparm and ddpt) can
 be built.
 
+Changelog for sg3_utils_lib-1.05 [20200304[svn: r11]
+  - copy the include and lib directories from sg3_utils
+    revision 844 which corresponds to release 1.45
+
 Changelog for sg3_utils_lib-1.04 [20190303[svn: r10]
   - copy the include and lib directories from sg3_utils
     revision 813
diff --git a/configure b/configure
index 597f62d..c58adb6 100755
--- a/configure
+++ b/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.69 for sg3_utils_lib 1.03.
+# Generated by GNU Autoconf 2.69 for sg3_utils_lib 1.04.
 #
 # Report bugs to <dgilbert@interlog.com>.
 #
@@ -590,8 +590,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='sg3_utils_lib'
 PACKAGE_TARNAME='sg3_utils_lib'
-PACKAGE_VERSION='1.03'
-PACKAGE_STRING='sg3_utils_lib 1.03'
+PACKAGE_VERSION='1.04'
+PACKAGE_STRING='sg3_utils_lib 1.04'
 PACKAGE_BUGREPORT='dgilbert@interlog.com'
 PACKAGE_URL=''
 
@@ -1352,7 +1352,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures sg3_utils_lib 1.03 to adapt to many kinds of systems.
+\`configure' configures sg3_utils_lib 1.04 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1423,7 +1423,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of sg3_utils_lib 1.03:";;
+     short | recursive ) echo "Configuration of sg3_utils_lib 1.04:";;
    esac
   cat <<\_ACEOF
 
@@ -1544,7 +1544,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-sg3_utils_lib configure 1.03
+sg3_utils_lib configure 1.04
 generated by GNU Autoconf 2.69
 
 Copyright (C) 2012 Free Software Foundation, Inc.
@@ -1913,7 +1913,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by sg3_utils_lib $as_me 1.03, which was
+It was created by sg3_utils_lib $as_me 1.04, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
@@ -2777,7 +2777,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='sg3_utils_lib'
- VERSION='1.03'
+ VERSION='1.04'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -13357,7 +13357,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by sg3_utils_lib $as_me 1.03, which was
+This file was extended by sg3_utils_lib $as_me 1.04, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -13423,7 +13423,7 @@ _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-sg3_utils_lib config.status 1.03
+sg3_utils_lib config.status 1.04
 configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
diff --git a/configure.ac b/configure.ac
index 4bfdfd1..97b053c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,4 +1,4 @@
-AC_INIT(sg3_utils_lib, 1.03, dgilbert@interlog.com)
+AC_INIT(sg3_utils_lib, 1.04, dgilbert@interlog.com)
 
 AM_INIT_AUTOMAKE([-Wall -Werror foreign])
 AM_MAINTAINER_MODE
diff --git a/include/Makefile.in b/include/Makefile.in
index d6029bf..6ee60f6 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2018 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -351,8 +351,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -443,7 +443,10 @@ cscopelist-am: $(am__tagged_files)
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
-distdir: $(DISTFILES)
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
+
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
diff --git a/include/sg_lib.h b/include/sg_lib.h
index 80c536c..1ece717 100644
--- a/include/sg_lib.h
+++ b/include/sg_lib.h
@@ -180,10 +180,10 @@ struct sg_scsi_sense_hdr {
     uint8_t sense_key;
     uint8_t asc;
     uint8_t ascq;
-    uint8_t byte4;
-    uint8_t byte5;
+    uint8_t byte4;      /* descriptor: SDAT_OVFL; fixed: lower three ... */
+    uint8_t byte5;      /* ... bytes of INFO field */
     uint8_t byte6;
-    uint8_t additional_length;
+    uint8_t additional_length;  /* zero for fixed format sense data */
 };
 
 /* Maps the salient data from a sense buffer which is in either fixed or
@@ -280,8 +280,8 @@ int sg_get_designation_descriptor_str(const char * leadin,
  * is lead-in string (on each line) than may be NULL. skip_prefix avoids
  * outputting: '   Locally assigned UUID: ' before the UUID. */
 int sg_t10_uuid_desig2str(const uint8_t * dp, int dlen, int c_set,
-			  bool do_long, bool skip_prefix,
-			  const char * lip, int blen, char * b);
+                          bool do_long, bool skip_prefix,
+                          const char * lip, int blen, char * b);
 
 /* Yield string associated with peripheral device type (pdt). Returns
  * 'buff'. If 'pdt' out of range yields "bad pdt" string. */
@@ -378,9 +378,21 @@ extern FILE * sg_warnings_strm;
 
 void sg_set_warnings_strm(FILE * warnings_strm);
 
+/* Given a SCSI command pointed to by cdbp of sz bytes this function forms a
+ * SCSI command in ASCII hex surrounded by square brackets in 'b'. 'b' is at
+ * least blen bytes long. If cmd_name is true then the command is prefixed
+ * by its SCSI command name (e.g.  "VERIFY(10) [2f ...]". The command is
+ * shown as spaced separated pairs of hexadecimal digits (i.e. 0-9, a-f).
+ * Each pair represents byte. The leftmost pair of digits is cdbp[0] . If
+ * sz <= 0 then this function tries to guess the length of the command. */
+char *
+sg_get_command_str(const uint8_t * cdbp, int sz, bool cmd_name, int blen,
+                   char * b);
+
 /* The following "print" functions send ASCII to 'sg_warnings_strm' file
  * descriptor (default value is stderr). 'leadin' is string prepended to
  * each line printed out, NULL treated as "". */
+void sg_print_command_len(const uint8_t * command, int len);
 void sg_print_command(const uint8_t * command);
 void sg_print_scsi_status(int scsi_status);
 
@@ -465,7 +477,7 @@ bool sg_exit2str(int exit_status, bool longer, int b_len, char * b);
 #define SG_LIB_CONTRADICT 31    /* error involving two or more cl options */
 #define SG_LIB_LOGIC_ERROR 32   /* unexpected situation in code */
 #define SG_LIB_WINDOWS_ERR 34   /* Windows error number don't fit in 7 bits so
-				 * map to a single value for exit statuses */
+                                 * map to a single value for exit statuses */
 #define SG_LIB_OK_FALSE 36      /* no error, reporting false (cf. no error,
                                  * reporting true is SG_LIB_OK_TRUE(0) ) */
 #define SG_LIB_CAT_PROTECTION 40 /* subset of aborted command (for PI, DIF)
@@ -569,6 +581,16 @@ void hex2stderr(const uint8_t * b_str, int len, int no_ascii);
 int hex2str(const uint8_t * b_str, int len, const char * leadin, int format,
             int cb_len, char * cbp);
 
+/* Read ASCII hex bytes or binary from fname (a file named '-' taken as
+ * stdin). If reading ASCII hex then there should be either one entry per
+ * line or a comma, space or tab separated list of bytes. If no_space is
+ * set then a string of ACSII hex digits is expected, 2 per byte. Everything
+ * from and including a '#' on a line is ignored. Returns 0 if ok, or an
+ * error code. If the error code is SG_LIB_LBA_OUT_OF_RANGE then mp_arr
+ * would be exceeded and both mp_arr and mp_arr_len are written to. */
+int sg_f2hex_arr(const char * fname, bool as_binary, bool no_space,
+                 uint8_t * mp_arr, int * mp_arr_len, int max_arr_len);
+
 /* Returns true when executed on big endian machine; else returns false.
  * Useful for displaying ATA identify words (which need swapping on a
  * big endian machine). */
@@ -603,13 +625,14 @@ int sg_ata_get_chars(const uint16_t * word_arr, int start_word,
 void dWordHex(const uint16_t * words, int num, int no_ascii, bool swapb);
 
 /* If the number in 'buf' can not be decoded or the multiplier is unknown
- * then -1 is returned. Accepts a hex prefix (0x or 0X) or a 'h' (or 'H')
- * suffix. Otherwise a decimal multiplier suffix may be given. Recognised
- * multipliers: c C  *1;  w W  *2; b  B *512;  k K KiB  *1,024;
- * KB  *1,000;  m M MiB  *1,048,576; MB *1,000,000; g G GiB *1,073,741,824;
- * GB *1,000,000,000 and <n>x<m> which multiplies <n> by <m> . Ignore leading
- * spaces and tabs; accept comma, hyphen, space, tab and hash as terminator.
- */
+ * then -1 is returned. Accepts a hex prefix (0x or 0X) or a decimal
+ * multiplier suffix (as per GNU's dd (since 2002: SI and IEC 60027-2)).
+ * Main (SI) multipliers supported: K, M, G. Ignore leading spaces and
+ * tabs; accept comma, hyphen, space, tab and hash as terminator.
+ * Handles zero and positive values up to 2**31-1 .
+ * Experimental: left argument (must in with hexadecimal digit) added
+ * to, or multiplied, by right argument. No embedded spaces.
+ * Examples: '3+1k' (evaluates to 1027) and '0xf+0x3'. */
 int sg_get_num(const char * buf);
 
 /* If the number in 'buf' can not be decoded then -1 is returned. Accepts a
@@ -620,12 +643,14 @@ int sg_get_num(const char * buf);
 int sg_get_num_nomult(const char * buf);
 
 /* If the number in 'buf' can not be decoded or the multiplier is unknown
- * then -1LL is returned. Accepts a hex prefix (0x or 0X) or a 'h' (or 'H')
- * suffix. Otherwise a decimal multiplier suffix may be given. In addition
- * to supporting the multipliers of sg_get_num(), this function supports:
- * t T TiB  *(2**40); TB *(10**12); p P PiB  *(2**50); PB  *(10**15) .
- * Ignore leading spaces and tabs; accept comma, hyphen, space, tab and hash
- * as terminator. */
+ * then -1LL is returned. Accepts a hex prefix (0x or 0X), hex suffix
+ * (h or H), or a decimal multiplier suffix (as per GNU's dd (since 2002:
+ * SI and IEC 60027-2)).  Main (SI) multipliers supported: K, M, G, T, P
+ * and E. Ignore leading spaces and tabs; accept comma, hyphen, space, tab
+ * and hash as terminator. Handles zero and positive values up to 2**63-1 .
+ * Experimental: the left argument (must end in with hexadecimal digit)
+ * added to, or multiplied by, the right argument. No embedded spaces.
+ * Examples: '3+1k' (evaluates to 1027) and '0xf+0x3'. */
 int64_t sg_get_llnum(const char * buf);
 
 /* If the number in 'buf' can not be decoded then -1 is returned. Accepts a
diff --git a/lib/Makefile.am b/lib/Makefile.am
index f90fed9..9c4867e 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -45,7 +45,7 @@ DBG_CPPFLAGS =
 endif
 
 # For C++/clang testing
-## CC = gcc-8
+## CC = gcc-9
 ## CC = g++
 ## CC = clang
 ## CC = clang++
@@ -63,7 +63,7 @@ AM_CFLAGS = -Wall -W $(DBG_CFLAGS)
 
 lib_LTLIBRARIES = libsgutils2.la
 
-libsgutils2_la_LDFLAGS = -version-info 2:0:0 -no-undefined
+libsgutils2_la_LDFLAGS = -version-info 2:0:0 -no-undefined -release ${PACKAGE_VERSION}
 
 libsgutils2_la_LIBADD = @GETOPT_O_FILES@
 libsgutils2_la_DEPENDENCIES = @GETOPT_O_FILES@
diff --git a/lib/Makefile.in b/lib/Makefile.in
index 1b28ad2..a8bcf6c 100644
--- a/lib/Makefile.in
+++ b/lib/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# Makefile.in generated by automake 1.16.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+# Copyright (C) 1994-2018 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -176,7 +176,15 @@ am__v_at_0 = @
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
+am__maybe_remake_depfiles = depfiles
+am__depfiles_remade = ./$(DEPDIR)/sg_cmds_basic.Plo \
+	./$(DEPDIR)/sg_cmds_basic2.Plo ./$(DEPDIR)/sg_cmds_extra.Plo \
+	./$(DEPDIR)/sg_cmds_mmc.Plo ./$(DEPDIR)/sg_io_linux.Plo \
+	./$(DEPDIR)/sg_lib.Plo ./$(DEPDIR)/sg_lib_data.Plo \
+	./$(DEPDIR)/sg_pt_common.Plo ./$(DEPDIR)/sg_pt_freebsd.Plo \
+	./$(DEPDIR)/sg_pt_linux.Plo ./$(DEPDIR)/sg_pt_linux_nvme.Plo \
+	./$(DEPDIR)/sg_pt_osf1.Plo ./$(DEPDIR)/sg_pt_solaris.Plo \
+	./$(DEPDIR)/sg_pt_win32.Plo
 am__mv = mv -f
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
@@ -368,7 +376,7 @@ AM_CFLAGS = -Wall -W $(DBG_CFLAGS)
 # AM_CFLAGS = -Wall -W -pedantic -std=c++14
 # AM_CFLAGS = -Wall -W -pedantic -std=c++1z
 lib_LTLIBRARIES = libsgutils2.la
-libsgutils2_la_LDFLAGS = -version-info 2:0:0 -no-undefined
+libsgutils2_la_LDFLAGS = -version-info 2:0:0 -no-undefined -release ${PACKAGE_VERSION}
 libsgutils2_la_LIBADD = @GETOPT_O_FILES@
 libsgutils2_la_DEPENDENCIES = @GETOPT_O_FILES@
 all: all-am
@@ -392,8 +400,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -449,20 +457,26 @@ mostlyclean-compile:
 distclean-compile:
 	-rm -f *.tab.c
 
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_cmds_basic.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_cmds_basic2.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_cmds_extra.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_cmds_mmc.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_io_linux.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_lib.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_lib_data.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_pt_common.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_pt_freebsd.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_pt_linux.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_pt_linux_nvme.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_pt_osf1.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_pt_solaris.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_pt_win32.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_cmds_basic.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_cmds_basic2.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_cmds_extra.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_cmds_mmc.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_io_linux.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_lib.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_lib_data.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_pt_common.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_pt_freebsd.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_pt_linux.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_pt_linux_nvme.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_pt_osf1.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_pt_solaris.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sg_pt_win32.Plo@am__quote@ # am--include-marker
+
+$(am__depfiles_remade):
+	@$(MKDIR_P) $(@D)
+	@echo '# dummy' >$@-t && $(am__mv) $@-t $@
+
+am--depfiles: $(am__depfiles_remade)
 
 .c.o:
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
@@ -543,7 +557,10 @@ cscopelist-am: $(am__tagged_files)
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
-distdir: $(DISTFILES)
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
+
+distdir-am: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
@@ -616,7 +633,20 @@ clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \
 	mostlyclean-am
 
 distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
+		-rm -f ./$(DEPDIR)/sg_cmds_basic.Plo
+	-rm -f ./$(DEPDIR)/sg_cmds_basic2.Plo
+	-rm -f ./$(DEPDIR)/sg_cmds_extra.Plo
+	-rm -f ./$(DEPDIR)/sg_cmds_mmc.Plo
+	-rm -f ./$(DEPDIR)/sg_io_linux.Plo
+	-rm -f ./$(DEPDIR)/sg_lib.Plo
+	-rm -f ./$(DEPDIR)/sg_lib_data.Plo
+	-rm -f ./$(DEPDIR)/sg_pt_common.Plo
+	-rm -f ./$(DEPDIR)/sg_pt_freebsd.Plo
+	-rm -f ./$(DEPDIR)/sg_pt_linux.Plo
+	-rm -f ./$(DEPDIR)/sg_pt_linux_nvme.Plo
+	-rm -f ./$(DEPDIR)/sg_pt_osf1.Plo
+	-rm -f ./$(DEPDIR)/sg_pt_solaris.Plo
+	-rm -f ./$(DEPDIR)/sg_pt_win32.Plo
 	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
@@ -662,7 +692,20 @@ install-ps-am:
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
+		-rm -f ./$(DEPDIR)/sg_cmds_basic.Plo
+	-rm -f ./$(DEPDIR)/sg_cmds_basic2.Plo
+	-rm -f ./$(DEPDIR)/sg_cmds_extra.Plo
+	-rm -f ./$(DEPDIR)/sg_cmds_mmc.Plo
+	-rm -f ./$(DEPDIR)/sg_io_linux.Plo
+	-rm -f ./$(DEPDIR)/sg_lib.Plo
+	-rm -f ./$(DEPDIR)/sg_lib_data.Plo
+	-rm -f ./$(DEPDIR)/sg_pt_common.Plo
+	-rm -f ./$(DEPDIR)/sg_pt_freebsd.Plo
+	-rm -f ./$(DEPDIR)/sg_pt_linux.Plo
+	-rm -f ./$(DEPDIR)/sg_pt_linux_nvme.Plo
+	-rm -f ./$(DEPDIR)/sg_pt_osf1.Plo
+	-rm -f ./$(DEPDIR)/sg_pt_solaris.Plo
+	-rm -f ./$(DEPDIR)/sg_pt_win32.Plo
 	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
@@ -683,9 +726,9 @@ uninstall-am: uninstall-libLTLIBRARIES
 
 .MAKE: install-am install-strip
 
-.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
-	clean-libLTLIBRARIES clean-libtool cscopelist-am ctags \
-	ctags-am distclean distclean-compile distclean-generic \
+.PHONY: CTAGS GTAGS TAGS all all-am am--depfiles check check-am clean \
+	clean-generic clean-libLTLIBRARIES clean-libtool cscopelist-am \
+	ctags ctags-am distclean distclean-compile distclean-generic \
 	distclean-libtool distclean-tags distdir dvi dvi-am html \
 	html-am info info-am install install-am install-data \
 	install-data-am install-dvi install-dvi-am install-exec \
diff --git a/lib/sg_cmds_basic.c b/lib/sg_cmds_basic.c
index 927c92a..c119c51 100644
--- a/lib/sg_cmds_basic.c
+++ b/lib/sg_cmds_basic.c
@@ -42,7 +42,7 @@
 #endif
 
 
-static const char * const version_str = "1.93 20190128";
+static const char * const version_str = "1.95 20191219";
 
 
 #define SENSE_BUFF_LEN 64       /* Arbitrary, could be larger */
@@ -364,7 +364,6 @@ create_pt_obj(const char * cname)
 static const char * const inquiry_s = "inquiry";
 
 
-
 /* Returns 0 on success, while positive values are SG_LIB_CAT_* errors
  * (e.g. SG_LIB_CAT_MALFORMED). If OS error, returns negated errno or -1. */
 static int
@@ -372,11 +371,16 @@ sg_ll_inquiry_com(struct sg_pt_base * ptvp, bool cmddt, bool evpd, int pg_op,
                   void * resp, int mx_resp_len, int timeout_secs,
                   int * residp, bool noisy, int verbose)
 {
-    int res, ret, k, sense_cat, resid;
+    int res, ret, sense_cat, resid;
     uint8_t inq_cdb[INQUIRY_CMDLEN] = {INQUIRY_CMD, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
     uint8_t * up;
 
+    if (resp == NULL) {
+        if (verbose)
+            pr2ws("Got NULL `resp` pointer");
+        return SG_LIB_CAT_MALFORMED;
+    }
     if (cmddt)
         inq_cdb[1] |= 0x2;
     if (evpd)
@@ -385,10 +389,11 @@ sg_ll_inquiry_com(struct sg_pt_base * ptvp, bool cmddt, bool evpd, int pg_op,
     /* 16 bit allocation length (was 8, increased in spc3r09, 200209) */
     sg_put_unaligned_be16((uint16_t)mx_resp_len, inq_cdb + 3);
     if (verbose) {
-        pr2ws("    %s cdb: ", inquiry_s);
-        for (k = 0; k < INQUIRY_CMDLEN; ++k)
-            pr2ws("%02x ", inq_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", inquiry_s,
+              sg_get_command_str(inq_cdb, INQUIRY_CMDLEN, false, sizeof(b),
+                                 b));
     }
     if (resp && (mx_resp_len > 0)) {
         up = (uint8_t *)resp;
@@ -594,15 +599,15 @@ sg_ll_test_unit_ready_progress_pt(struct sg_pt_base * ptvp, int pack_id,
                                   int * progress, bool noisy, int verbose)
 {
     static const char * const tur_s = "test unit ready";
-    int res, ret, k, sense_cat;
+    int res, ret, sense_cat;
     uint8_t tur_cdb[TUR_CMDLEN] = {TUR_CMD, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
 
     if (verbose) {
-        pr2ws("    %s cdb: ", tur_s);
-        for (k = 0; k < TUR_CMDLEN; ++k)
-            pr2ws("%02x ", tur_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", tur_s,
+              sg_get_command_str(tur_cdb, TUR_CMDLEN, false, sizeof(b), b));
     }
 
     clear_scsi_pt_obj(ptvp);
@@ -684,7 +689,7 @@ sg_ll_request_sense_com(struct sg_pt_base * ptvp, int sg_fd, bool desc,
                         void * resp, int mx_resp_len, bool noisy, int verbose)
 {
     bool ptvp_given = false;
-    int k, ret, res, sense_cat;
+    int ret, res, sense_cat;
     static const char * const rq_s = "request sense";
     uint8_t rs_cdb[REQUEST_SENSE_CMDLEN] =
         {REQUEST_SENSE_CMD, 0, 0, 0, 0, 0};
@@ -698,12 +703,12 @@ sg_ll_request_sense_com(struct sg_pt_base * ptvp, int sg_fd, bool desc,
     }
     rs_cdb[4] = mx_resp_len & 0xff;
     if (verbose) {
-        pr2ws("    %s cmd: ", rq_s);
-        for (k = 0; k < REQUEST_SENSE_CMDLEN; ++k)
-            pr2ws("%02x ", rs_cdb[k]);
-        pr2ws("\n");
-    }
+        char b[128];
 
+        pr2ws("    %s cdb: %s\n", rq_s,
+              sg_get_command_str(rs_cdb, REQUEST_SENSE_CMDLEN, false,
+                                 sizeof(b), b));
+    }
     if (ptvp)
         ptvp_given = true;
     else {
@@ -767,7 +772,7 @@ sg_ll_report_luns_com(struct sg_pt_base * ptvp, int sg_fd, int select_report,
 {
     static const char * const report_luns_s = "report luns";
     bool ptvp_given = false;
-    int k, ret, res, sense_cat;
+    int ret, res, sense_cat;
     uint8_t rl_cdb[REPORT_LUNS_CMDLEN] =
                          {REPORT_LUNS_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -775,12 +780,12 @@ sg_ll_report_luns_com(struct sg_pt_base * ptvp, int sg_fd, int select_report,
     rl_cdb[2] = select_report & 0xff;
     sg_put_unaligned_be32((uint32_t)mx_resp_len, rl_cdb + 6);
     if (verbose) {
-        pr2ws("    %s cdb: ", report_luns_s);
-        for (k = 0; k < REPORT_LUNS_CMDLEN; ++k)
-            pr2ws("%02x ", rl_cdb[k]);
-        pr2ws("\n");
-    }
+        char b[128];
 
+        pr2ws("    %s cdb: %s\n", report_luns_s,
+              sg_get_command_str(rl_cdb, REPORT_LUNS_CMDLEN, false,
+                                 sizeof(b), b));
+    }
     if (ptvp)
         ptvp_given = true;
     else if (NULL == ((ptvp = create_pt_obj(report_luns_s))))
diff --git a/lib/sg_cmds_basic2.c b/lib/sg_cmds_basic2.c
index e853638..c6c8c0b 100644
--- a/lib/sg_cmds_basic2.c
+++ b/lib/sg_cmds_basic2.c
@@ -90,7 +90,7 @@ sg_ll_sync_cache_10(int sg_fd, bool sync_nv, bool immed, int group,
                     int verbose)
 {
     static const char * const cdb_s = "synchronize cache(10)";
-    int res, ret, k, sense_cat;
+    int res, ret, sense_cat;
     uint8_t sc_cdb[SYNCHRONIZE_CACHE_CMDLEN] =
                 {SYNCHRONIZE_CACHE_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -109,10 +109,11 @@ sg_ll_sync_cache_10(int sg_fd, bool sync_nv, bool immed, int group,
     sg_put_unaligned_be16((int16_t)count, sc_cdb + 7);
 
     if (verbose) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < SYNCHRONIZE_CACHE_CMDLEN; ++k)
-            pr2ws("%02x ", sc_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(sc_cdb, SYNCHRONIZE_CACHE_CMDLEN, false,
+                                 sizeof(b), b));
     }
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
         return -1;
@@ -146,7 +147,7 @@ sg_ll_readcap_16(int sg_fd, bool pmi, uint64_t llba, void * resp,
                  int mx_resp_len, bool noisy, int verbose)
 {
     static const char * const cdb_s = "read capacity(16)";
-    int k, ret, res, sense_cat;
+    int ret, res, sense_cat;
     uint8_t rc_cdb[SERVICE_ACTION_IN_16_CMDLEN] =
                         {SERVICE_ACTION_IN_16_CMD, READ_CAPACITY_16_SA,
                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
@@ -160,10 +161,11 @@ sg_ll_readcap_16(int sg_fd, bool pmi, uint64_t llba, void * resp,
     /* Allocation length, no guidance in SBC-2 rev 15b */
     sg_put_unaligned_be32((uint32_t)mx_resp_len, rc_cdb + 10);
     if (verbose) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < SERVICE_ACTION_IN_16_CMDLEN; ++k)
-            pr2ws("%02x ", rc_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(rc_cdb, SERVICE_ACTION_IN_16_CMDLEN, false,
+                                 sizeof(b), b));
     }
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
         return -1;
@@ -198,7 +200,7 @@ sg_ll_readcap_10(int sg_fd, bool pmi, unsigned int lba, void * resp,
                  int mx_resp_len, bool noisy, int verbose)
 {
     static const char * const cdb_s = "read capacity(10)";
-    int k, ret, res, sense_cat;
+    int ret, res, sense_cat;
     uint8_t rc_cdb[READ_CAPACITY_10_CMDLEN] =
                          {READ_CAPACITY_10_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -209,10 +211,11 @@ sg_ll_readcap_10(int sg_fd, bool pmi, unsigned int lba, void * resp,
         sg_put_unaligned_be32((uint32_t)lba, rc_cdb + 2);
     }
     if (verbose) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < READ_CAPACITY_10_CMDLEN; ++k)
-            pr2ws("%02x ", rc_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(rc_cdb, READ_CAPACITY_10_CMDLEN, false,
+                                 sizeof(b), b));
     }
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
         return -1;
@@ -247,7 +250,7 @@ sg_ll_mode_sense6(int sg_fd, bool dbd, int pc, int pg_code, int sub_pg_code,
                   void * resp, int mx_resp_len, bool noisy, int verbose)
 {
     static const char * const cdb_s = "mode sense(6)";
-    int res, ret, k, sense_cat, resid;
+    int res, ret, sense_cat, resid;
     uint8_t modes_cdb[MODE_SENSE6_CMDLEN] =
         {MODE_SENSE6_CMD, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -262,10 +265,11 @@ sg_ll_mode_sense6(int sg_fd, bool dbd, int pc, int pg_code, int sub_pg_code,
         return -1;
     }
     if (verbose) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < MODE_SENSE6_CMDLEN; ++k)
-            pr2ws("%02x ", modes_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(modes_cdb, MODE_SENSE6_CMDLEN, false,
+                                 sizeof(b), b));
     }
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
         return -1;
@@ -340,7 +344,7 @@ sg_ll_mode_sense10_v2(int sg_fd, bool llbaa, bool dbd, int pc, int pg_code,
                       int sub_pg_code, void * resp, int mx_resp_len,
                       int timeout_secs, int * residp, bool noisy, int verbose)
 {
-    int res, ret, k, sense_cat, resid;
+    int res, ret, sense_cat, resid;
     static const char * const cdb_s = "mode sense(10)";
     struct sg_pt_base * ptvp;
     uint8_t modes_cdb[MODE_SENSE10_CMDLEN] =
@@ -356,10 +360,11 @@ sg_ll_mode_sense10_v2(int sg_fd, bool llbaa, bool dbd, int pc, int pg_code,
         goto gen_err;
     }
     if (verbose) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < MODE_SENSE10_CMDLEN; ++k)
-            pr2ws("%02x ", modes_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(modes_cdb, MODE_SENSE10_CMDLEN, false,
+                                 sizeof(b), b));
     }
     if (timeout_secs <= 0)
         timeout_secs = DEF_PT_TIMEOUT;
@@ -425,7 +430,7 @@ sg_ll_mode_select6_v2(int sg_fd, bool pf, bool rtd, bool sp, void * paramp,
                       int param_len, bool noisy, int verbose)
 {
     static const char * const cdb_s = "mode select(6)";
-    int res, ret, k, sense_cat;
+    int res, ret, sense_cat;
     uint8_t modes_cdb[MODE_SELECT6_CMDLEN] =
         {MODE_SELECT6_CMD, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -440,10 +445,11 @@ sg_ll_mode_select6_v2(int sg_fd, bool pf, bool rtd, bool sp, void * paramp,
         return -1;
     }
     if (verbose) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < MODE_SELECT6_CMDLEN; ++k)
-            pr2ws("%02x ", modes_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(modes_cdb, MODE_SELECT6_CMDLEN, false,
+                                 sizeof(b), b));
     }
     if (verbose > 1) {
         pr2ws("    %s parameter list\n", cdb_s);
@@ -492,7 +498,7 @@ sg_ll_mode_select10_v2(int sg_fd, bool pf, bool rtd, bool sp, void * paramp,
                        int param_len, bool noisy, int verbose)
 {
     static const char * const cdb_s = "mode select(10)";
-    int res, ret, k, sense_cat;
+    int res, ret, sense_cat;
     uint8_t modes_cdb[MODE_SELECT10_CMDLEN] =
         {MODE_SELECT10_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -507,10 +513,11 @@ sg_ll_mode_select10_v2(int sg_fd, bool pf, bool rtd, bool sp, void * paramp,
         return -1;
     }
     if (verbose) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < MODE_SELECT10_CMDLEN; ++k)
-            pr2ws("%02x ", modes_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(modes_cdb, MODE_SELECT10_CMDLEN, false,
+                                 sizeof(b), b));
     }
     if (verbose > 1) {
         pr2ws("    %s parameter list\n", cdb_s);
@@ -787,7 +794,7 @@ sg_ll_log_sense_v2(int sg_fd, bool ppc, bool sp, int pc, int pg_code,
                    bool noisy, int verbose)
 {
     static const char * const cdb_s = "log sense";
-    int res, ret, k, sense_cat, resid;
+    int res, ret, sense_cat, resid;
     uint8_t logs_cdb[LOG_SENSE_CMDLEN] =
         {LOG_SENSE_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -803,10 +810,11 @@ sg_ll_log_sense_v2(int sg_fd, bool ppc, bool sp, int pc, int pg_code,
     sg_put_unaligned_be16((int16_t)paramp, logs_cdb + 5);
     sg_put_unaligned_be16((int16_t)mx_resp_len, logs_cdb + 7);
     if (verbose) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < LOG_SENSE_CMDLEN; ++k)
-            pr2ws("%02x ", logs_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(logs_cdb, LOG_SENSE_CMDLEN, false,
+                                 sizeof(b), b));
     }
     if (timeout_secs <= 0)
         timeout_secs = DEF_PT_TIMEOUT;
@@ -867,7 +875,7 @@ sg_ll_log_select(int sg_fd, bool pcr, bool sp, int pc, int pg_code,
                  bool noisy, int verbose)
 {
     static const char * const cdb_s = "log select";
-    int res, ret, k, sense_cat;
+    int res, ret, sense_cat;
     uint8_t logs_cdb[LOG_SELECT_CMDLEN] =
         {LOG_SELECT_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -882,10 +890,11 @@ sg_ll_log_select(int sg_fd, bool pcr, bool sp, int pc, int pg_code,
     logs_cdb[3] = (uint8_t)(subpg_code & 0xff);
     sg_put_unaligned_be16((int16_t)param_len, logs_cdb + 7);
     if (verbose) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < LOG_SELECT_CMDLEN; ++k)
-            pr2ws("%02x ", logs_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(logs_cdb, LOG_SELECT_CMDLEN, false,
+                                 sizeof(b), b));
     }
     if ((verbose > 1) && (param_len > 0)) {
         pr2ws("    %s parameter list\n", cdb_s);
@@ -949,7 +958,7 @@ sg_ll_start_stop_unit_pt(struct sg_pt_base * ptvp, bool immed,
                          bool loej, bool start, bool noisy, int verbose)
 {
     static const char * const cdb_s = "start stop unit";
-    int k, res, ret, sense_cat;
+    int res, ret, sense_cat;
     uint8_t ssuBlk[START_STOP_CMDLEN] = {START_STOP_CMD, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
 
@@ -964,10 +973,11 @@ sg_ll_start_stop_unit_pt(struct sg_pt_base * ptvp, bool immed,
     if (start)
         ssuBlk[4] |= 0x1;
     if (verbose) {
-        pr2ws("    %s command:", cdb_s);
-        for (k = 0; k < (int)sizeof(ssuBlk); ++k)
-                pr2ws(" %02x", ssuBlk[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(ssuBlk, sizeof(ssuBlk), false,
+                                 sizeof(b), b));
     }
 
     clear_scsi_pt_obj(ptvp);
@@ -1001,7 +1011,7 @@ int
 sg_ll_prevent_allow(int sg_fd, int prevent, bool noisy, int verbose)
 {
     static const char * const cdb_s = "prevent allow medium removal";
-    int k, res, ret, sense_cat;
+    int res, ret, sense_cat;
     uint8_t p_cdb[PREVENT_ALLOW_CMDLEN] =
                 {PREVENT_ALLOW_CMD, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -1013,10 +1023,11 @@ sg_ll_prevent_allow(int sg_fd, int prevent, bool noisy, int verbose)
     }
     p_cdb[4] |= (prevent & 0x3);
     if (verbose) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < PREVENT_ALLOW_CMDLEN; ++k)
-            pr2ws("%02x ", p_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(p_cdb, PREVENT_ALLOW_CMDLEN, false,
+                                 sizeof(b), b));
     }
 
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
diff --git a/lib/sg_cmds_extra.c b/lib/sg_cmds_extra.c
index 9655888..71af035 100644
--- a/lib/sg_cmds_extra.c
+++ b/lib/sg_cmds_extra.c
@@ -123,7 +123,7 @@ sg_ll_get_lba_status16(int sg_fd, uint64_t start_llba, uint8_t rt,
                       void * resp, int alloc_len, bool noisy, int vb)
 {
     static const char * const cdb_s = "Get LBA status(16)";
-    int k, res, s_cat, ret;
+    int res, s_cat, ret;
     uint8_t getLbaStatCmd[SERVICE_ACTION_IN_16_CMDLEN];
     uint8_t sense_b[SENSE_BUFF_LEN];
     struct sg_pt_base * ptvp;
@@ -136,10 +136,11 @@ sg_ll_get_lba_status16(int sg_fd, uint64_t start_llba, uint8_t rt,
     sg_put_unaligned_be32((uint32_t)alloc_len, getLbaStatCmd + 10);
     getLbaStatCmd[14] = rt;
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < SERVICE_ACTION_IN_16_CMDLEN; ++k)
-            pr2ws("%02x ", getLbaStatCmd[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(getLbaStatCmd, SERVICE_ACTION_IN_16_CMDLEN,
+                                 false, sizeof(b), b));
     }
 
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
@@ -196,7 +197,7 @@ sg_ll_get_lba_status32(int sg_fd, uint64_t start_llba, uint32_t scan_len,
                        int vb)
 {
     static const char * const cdb_s = "Get LBA status(32)";
-    int k, res, s_cat, ret;
+    int res, s_cat, ret;
     uint8_t gls32_cmd[GLS32_CMD_LEN];
     uint8_t sense_b[SENSE_BUFF_LEN];
     struct sg_pt_base * ptvp;
@@ -211,10 +212,11 @@ sg_ll_get_lba_status32(int sg_fd, uint64_t start_llba, uint32_t scan_len,
     sg_put_unaligned_be32(element_id, gls32_cmd + 24);
     sg_put_unaligned_be32((uint32_t)alloc_len, gls32_cmd + 28);
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < GLS32_CMD_LEN; ++k)
-            pr2ws("%02x ", gls32_cmd[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(gls32_cmd, GLS32_CMD_LEN, false, sizeof(b),
+                                 b));
     }
 
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
@@ -269,7 +271,7 @@ sg_ll_report_tgt_prt_grp2(int sg_fd, void * resp, int mx_resp_len,
                           bool extended, bool noisy, int vb)
 {
     static const char * const cdb_s = "Report target port groups";
-    int k, res, ret, s_cat;
+    int res, ret, s_cat;
     uint8_t rtpg_cdb[MAINTENANCE_IN_CMDLEN] =
                          {MAINTENANCE_IN_CMD, REPORT_TGT_PRT_GRP_SA,
                           0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
@@ -280,10 +282,11 @@ sg_ll_report_tgt_prt_grp2(int sg_fd, void * resp, int mx_resp_len,
         rtpg_cdb[1] |= 0x20;
     sg_put_unaligned_be32((uint32_t)mx_resp_len, rtpg_cdb + 6);
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < MAINTENANCE_IN_CMDLEN; ++k)
-            pr2ws("%02x ", rtpg_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(rtpg_cdb, MAINTENANCE_IN_CMDLEN,
+                                 false, sizeof(b), b));
     }
 
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
@@ -330,7 +333,7 @@ sg_ll_set_tgt_prt_grp(int sg_fd, void * paramp, int param_len, bool noisy,
                       int vb)
 {
     static const char * const cdb_s = "Set target port groups";
-    int k, res, ret, s_cat;
+    int res, ret, s_cat;
     uint8_t stpg_cdb[MAINTENANCE_OUT_CMDLEN] =
                          {MAINTENANCE_OUT_CMD, SET_TGT_PRT_GRP_SA,
                           0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
@@ -339,10 +342,11 @@ sg_ll_set_tgt_prt_grp(int sg_fd, void * paramp, int param_len, bool noisy,
 
     sg_put_unaligned_be32((uint32_t)param_len, stpg_cdb + 6);
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < MAINTENANCE_OUT_CMDLEN; ++k)
-            pr2ws("%02x ", stpg_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(stpg_cdb, MAINTENANCE_OUT_CMDLEN,
+                                 false, sizeof(b), b));
         if ((vb > 1) && paramp && param_len) {
             pr2ws("    %s parameter list:\n", cdb_s);
             hex2stderr((const uint8_t *)paramp, param_len, -1);
@@ -382,7 +386,7 @@ sg_ll_report_referrals(int sg_fd, uint64_t start_llba, bool one_seg,
                        int vb)
 {
     static const char * const cdb_s = "Report referrals";
-    int k, res, ret, s_cat;
+    int res, ret, s_cat;
     uint8_t repRef_cdb[SERVICE_ACTION_IN_16_CMDLEN] =
                          {SERVICE_ACTION_IN_16_CMD, REPORT_REFERRALS_SA,
                           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
@@ -394,10 +398,11 @@ sg_ll_report_referrals(int sg_fd, uint64_t start_llba, bool one_seg,
     if (one_seg)
         repRef_cdb[14] = 0x1;
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < SERVICE_ACTION_IN_16_CMDLEN; ++k)
-            pr2ws("%02x ", repRef_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(repRef_cdb, SERVICE_ACTION_IN_16_CMDLEN,
+                                 false, sizeof(b), b));
     }
 
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
@@ -449,7 +454,7 @@ sg_ll_send_diag_pt(struct sg_pt_base * ptvp, int st_code, bool pf_bit,
                    bool noisy, int vb)
 {
     static const char * const cdb_s = "Send diagnostic";
-    int k, res, ret, s_cat, tmout;
+    int res, ret, s_cat, tmout;
     uint8_t senddiag_cdb[SEND_DIAGNOSTIC_CMDLEN] =
         {SEND_DIAGNOSTIC_CMD, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -470,10 +475,11 @@ sg_ll_send_diag_pt(struct sg_pt_base * ptvp, int st_code, bool pf_bit,
         tmout = long_duration ? LONG_PT_TIMEOUT : DEF_PT_TIMEOUT;
 
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < SEND_DIAGNOSTIC_CMDLEN; ++k)
-            pr2ws("%02x ", senddiag_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(senddiag_cdb, SEND_DIAGNOSTIC_CMDLEN,
+                                 false, sizeof(b), b));
         if (vb > 1) {
             if (paramp && param_len) {
                 pr2ws("    %s parameter list:\n", cdb_s);
@@ -532,7 +538,7 @@ sg_ll_receive_diag_pt(struct sg_pt_base * ptvp, bool pcv, int pg_code,
                       int * residp, bool noisy, int vb)
 {
     int resid = 0;
-    int k, res, ret, s_cat;
+    int res, ret, s_cat;
     static const char * const cdb_s = "Receive diagnostic results";
     uint8_t rcvdiag_cdb[RECEIVE_DIAGNOSTICS_CMDLEN] =
         {RECEIVE_DIAGNOSTICS_CMD, 0, 0, 0, 0, 0};
@@ -544,10 +550,11 @@ sg_ll_receive_diag_pt(struct sg_pt_base * ptvp, bool pcv, int pg_code,
     sg_put_unaligned_be16((uint16_t)mx_resp_len, rcvdiag_cdb + 3);
 
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < RECEIVE_DIAGNOSTICS_CMDLEN; ++k)
-            pr2ws("%02x ", rcvdiag_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(rcvdiag_cdb, RECEIVE_DIAGNOSTICS_CMDLEN,
+                                 false, sizeof(b), b));
     }
     if (timeout_secs <= 0)
         timeout_secs = DEF_PT_TIMEOUT;
@@ -632,7 +639,7 @@ sg_ll_read_defect10(int sg_fd, bool req_plist, bool req_glist, int dl_format,
                     void * resp, int mx_resp_len, bool noisy, int vb)
 {
     static const char * const cdb_s = "Read defect(10)";
-    int res, k, ret, s_cat;
+    int res, ret, s_cat;
     uint8_t rdef_cdb[READ_DEFECT10_CMDLEN] =
         {READ_DEFECT10_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -649,10 +656,11 @@ sg_ll_read_defect10(int sg_fd, bool req_plist, bool req_glist, int dl_format,
         return -1;
     }
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < READ_DEFECT10_CMDLEN; ++k)
-            pr2ws("%02x ", rdef_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(rdef_cdb, READ_DEFECT10_CMDLEN,
+                                 false, sizeof(b), b));
     }
 
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
@@ -699,7 +707,7 @@ sg_ll_read_media_serial_num(int sg_fd, void * resp, int mx_resp_len,
                             bool noisy, int vb)
 {
     static const char * const cdb_s = "Read media serial number";
-    int k, res, ret, s_cat;
+    int res, ret, s_cat;
     uint8_t rmsn_cdb[SERVICE_ACTION_IN_12_CMDLEN] =
                          {SERVICE_ACTION_IN_12_CMD, READ_MEDIA_SERIAL_NUM_SA,
                           0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
@@ -708,10 +716,11 @@ sg_ll_read_media_serial_num(int sg_fd, void * resp, int mx_resp_len,
 
     sg_put_unaligned_be32((uint32_t)mx_resp_len, rmsn_cdb + 6);
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < SERVICE_ACTION_IN_12_CMDLEN; ++k)
-            pr2ws("%02x ", rmsn_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(rmsn_cdb, SERVICE_ACTION_IN_12_CMDLEN,
+                                 false, sizeof(b), b));
     }
 
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
@@ -759,7 +768,7 @@ sg_ll_report_id_info(int sg_fd, int itype, void * resp, int max_resp_len,
                      bool noisy, int vb)
 {
     static const char * const cdb_s = "Report identifying information";
-    int k, res, ret, s_cat;
+    int res, ret, s_cat;
     uint8_t rii_cdb[MAINTENANCE_IN_CMDLEN] = {MAINTENANCE_IN_CMD,
                         REPORT_IDENTIFYING_INFORMATION_SA,
                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
@@ -770,10 +779,11 @@ sg_ll_report_id_info(int sg_fd, int itype, void * resp, int max_resp_len,
     rii_cdb[10] |= (itype << 1) & 0xfe;
 
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < MAINTENANCE_IN_CMDLEN; ++k)
-            pr2ws("%02x ", rii_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(rii_cdb, MAINTENANCE_IN_CMDLEN,
+                                 false, sizeof(b), b));
     }
 
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
@@ -821,7 +831,7 @@ sg_ll_set_id_info(int sg_fd, int itype, void * paramp, int param_len,
                   bool noisy, int vb)
 {
     static const char * const cdb_s = "Set identifying information";
-    int k, res, ret, s_cat;
+    int res, ret, s_cat;
     uint8_t sii_cdb[MAINTENANCE_OUT_CMDLEN] = {MAINTENANCE_OUT_CMD,
                          SET_IDENTIFYING_INFORMATION_SA,
                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
@@ -831,10 +841,11 @@ sg_ll_set_id_info(int sg_fd, int itype, void * paramp, int param_len,
     sg_put_unaligned_be32((uint32_t)param_len, sii_cdb + 6);
     sii_cdb[10] |= (itype << 1) & 0xfe;
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < MAINTENANCE_OUT_CMDLEN; ++k)
-            pr2ws("%02x ", sii_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(sii_cdb, MAINTENANCE_OUT_CMDLEN,
+                                 false, sizeof(b), b));
         if ((vb > 1) && paramp && param_len) {
             pr2ws("    %s parameter list:\n", cdb_s);
             hex2stderr((const uint8_t *)paramp, param_len, -1);
@@ -901,7 +912,7 @@ sg_ll_format_unit_v2(int sg_fd, int fmtpinfo, bool longlist, bool fmtdata,
                      bool noisy, int vb)
 {
     static const char * const cdb_s = "Format unit";
-    int k, res, ret, s_cat, tmout;
+    int res, ret, s_cat, tmout;
     uint8_t fu_cdb[FORMAT_UNIT_CMDLEN] =
                 {FORMAT_UNIT_CMD, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -921,10 +932,10 @@ sg_ll_format_unit_v2(int sg_fd, int fmtpinfo, bool longlist, bool fmtdata,
         fu_cdb[4] |= (ffmt & 0x3);
     tmout = (timeout_secs > 0) ? timeout_secs : DEF_PT_TIMEOUT;
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < 6; ++k)
-            pr2ws("%02x ", fu_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(fu_cdb, 6, false, sizeof(b), b));
         if (vb > 1) {
             if (param_len > 0) {
                 pr2ws("    %s parameter list:\n", cdb_s);
@@ -967,7 +978,7 @@ sg_ll_reassign_blocks(int sg_fd, bool longlba, bool longlist, void * paramp,
                       int param_len, bool noisy, int vb)
 {
     static const char * const cdb_s = "Reassign blocks";
-    int res, k, ret, s_cat;
+    int res, ret, s_cat;
     uint8_t reass_cdb[REASSIGN_BLKS_CMDLEN] =
         {REASSIGN_BLKS_CMD, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -978,10 +989,11 @@ sg_ll_reassign_blocks(int sg_fd, bool longlba, bool longlist, void * paramp,
     if (longlist)
         reass_cdb[1] |= 0x1;
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < REASSIGN_BLKS_CMDLEN; ++k)
-            pr2ws("%02x ", reass_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(reass_cdb, REASSIGN_BLKS_CMDLEN, false,
+                                 sizeof(b), b));
     }
     if (vb > 1) {
         pr2ws("    %s parameter list\n", cdb_s);
@@ -1022,7 +1034,7 @@ sg_ll_persistent_reserve_in(int sg_fd, int rq_servact, void * resp,
                             int mx_resp_len, bool noisy, int vb)
 {
     static const char * const cdb_s = "Persistent reservation in";
-    int res, k, ret, s_cat;
+    int res, ret, s_cat;
     uint8_t prin_cdb[PERSISTENT_RESERVE_IN_CMDLEN] =
                  {PERSISTENT_RESERVE_IN_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -1033,10 +1045,11 @@ sg_ll_persistent_reserve_in(int sg_fd, int rq_servact, void * resp,
     sg_put_unaligned_be16((uint16_t)mx_resp_len, prin_cdb + 7);
 
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < PERSISTENT_RESERVE_IN_CMDLEN; ++k)
-            pr2ws("%02x ", prin_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(prin_cdb, PERSISTENT_RESERVE_IN_CMDLEN,
+                                 false, sizeof(b), b));
     }
 
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
@@ -1085,7 +1098,7 @@ sg_ll_persistent_reserve_out(int sg_fd, int rq_servact, int rq_scope,
                              int param_len, bool noisy, int vb)
 {
     static const char * const cdb_s = "Persistent reservation out";
-    int res, k, ret, s_cat;
+    int res, ret, s_cat;
     uint8_t prout_cdb[PERSISTENT_RESERVE_OUT_CMDLEN] =
                  {PERSISTENT_RESERVE_OUT_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -1097,10 +1110,11 @@ sg_ll_persistent_reserve_out(int sg_fd, int rq_servact, int rq_scope,
     sg_put_unaligned_be16((uint16_t)param_len, prout_cdb + 7);
 
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < PERSISTENT_RESERVE_OUT_CMDLEN; ++k)
-            pr2ws("%02x ", prout_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(prout_cdb, PERSISTENT_RESERVE_OUT_CMDLEN,
+                                 false, sizeof(b), b));
         if (vb > 1) {
             pr2ws("    %s parameters:\n", cdb_s);
             hex2stderr((const uint8_t *)paramp, param_len, 0);
@@ -1160,7 +1174,7 @@ sg_ll_read_long10(int sg_fd, bool pblock, bool correct, unsigned int lba,
                   int vb)
 {
     static const char * const cdb_s = "read long(10)";
-    int k, res, s_cat, ret;
+    int res, s_cat, ret;
     uint8_t readLong_cdb[READ_LONG10_CMDLEN];
     uint8_t sense_b[SENSE_BUFF_LEN];
     struct sg_pt_base * ptvp;
@@ -1175,10 +1189,11 @@ sg_ll_read_long10(int sg_fd, bool pblock, bool correct, unsigned int lba,
     sg_put_unaligned_be32((uint32_t)lba, readLong_cdb + 2);
     sg_put_unaligned_be16((uint16_t)xfer_len, readLong_cdb + 7);
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < READ_LONG10_CMDLEN; ++k)
-            pr2ws("%02x ", readLong_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(readLong_cdb, READ_LONG10_CMDLEN,
+                                 false, sizeof(b), b));
     }
 
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
@@ -1248,7 +1263,7 @@ sg_ll_read_long16(int sg_fd, bool pblock, bool correct, uint64_t llba,
                   int vb)
 {
     static const char * const cdb_s = "read long(16)";
-    int k, res, s_cat, ret;
+    int res, s_cat, ret;
     uint8_t readLong_cdb[SERVICE_ACTION_IN_16_CMDLEN];
     uint8_t sense_b[SENSE_BUFF_LEN];
     struct sg_pt_base * ptvp;
@@ -1264,10 +1279,11 @@ sg_ll_read_long16(int sg_fd, bool pblock, bool correct, uint64_t llba,
     sg_put_unaligned_be64(llba, readLong_cdb + 2);
     sg_put_unaligned_be16((uint16_t)xfer_len, readLong_cdb + 12);
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < SERVICE_ACTION_IN_16_CMDLEN; ++k)
-            pr2ws("%02x ", readLong_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(readLong_cdb, SERVICE_ACTION_IN_16_CMDLEN,
+                                 false, sizeof(b), b));
     }
 
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
@@ -1337,7 +1353,7 @@ sg_ll_write_long10(int sg_fd, bool cor_dis, bool wr_uncor, bool pblock,
                    int * offsetp, bool noisy, int vb)
 {
     static const char * const cdb_s = "write long(10)";
-    int k, res, s_cat, ret;
+    int res, s_cat, ret;
     uint8_t writeLong_cdb[WRITE_LONG10_CMDLEN];
     uint8_t sense_b[SENSE_BUFF_LEN];
     struct sg_pt_base * ptvp;
@@ -1354,10 +1370,11 @@ sg_ll_write_long10(int sg_fd, bool cor_dis, bool wr_uncor, bool pblock,
     sg_put_unaligned_be32((uint32_t)lba, writeLong_cdb + 2);
     sg_put_unaligned_be16((uint16_t)xfer_len, writeLong_cdb + 7);
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < (int)sizeof(writeLong_cdb); ++k)
-            pr2ws("%02x ", writeLong_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(writeLong_cdb, (int)sizeof(writeLong_cdb),
+                                 false, sizeof(b), b));
     }
 
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
@@ -1415,7 +1432,7 @@ sg_ll_write_long16(int sg_fd, bool cor_dis, bool wr_uncor, bool pblock,
                    int * offsetp, bool noisy, int vb)
 {
     static const char * const cdb_s = "write long(16)";
-    int k, res, s_cat, ret;
+    int res, s_cat, ret;
     uint8_t writeLong_cdb[SERVICE_ACTION_OUT_16_CMDLEN];
     uint8_t sense_b[SENSE_BUFF_LEN];
     struct sg_pt_base * ptvp;
@@ -1433,10 +1450,11 @@ sg_ll_write_long16(int sg_fd, bool cor_dis, bool wr_uncor, bool pblock,
     sg_put_unaligned_be64(llba, writeLong_cdb + 2);
     sg_put_unaligned_be16((uint16_t)xfer_len, writeLong_cdb + 12);
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < SERVICE_ACTION_OUT_16_CMDLEN; ++k)
-            pr2ws("%02x ", writeLong_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(writeLong_cdb, SERVICE_ACTION_OUT_16_CMDLEN,
+                                 false, sizeof(b), b));
     }
 
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
@@ -1510,10 +1528,11 @@ sg_ll_verify10(int sg_fd, int vrprotect, bool dpo, int bytchk,
     sg_put_unaligned_be32((uint32_t)lba, v_cdb + 2);
     sg_put_unaligned_be16((uint16_t)veri_len, v_cdb + 7);
     if (vb > 1) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < VERIFY10_CMDLEN; ++k)
-            pr2ws("%02x ", v_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(v_cdb, VERIFY10_CMDLEN,
+                                 false, sizeof(b), b));
         if ((vb > 3) && bytchk && data_out && (data_out_len > 0)) {
             k = data_out_len > 4104 ? 4104 : data_out_len;
             pr2ws("    data_out buffer%s\n",
@@ -1587,10 +1606,11 @@ sg_ll_verify16(int sg_fd, int vrprotect, bool dpo, int bytchk, uint64_t llba,
     sg_put_unaligned_be32((uint32_t)veri_len, v_cdb + 10);
     v_cdb[14] = group_num & 0x1f;
     if (vb > 1) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < VERIFY16_CMDLEN; ++k)
-            pr2ws("%02x ", v_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(v_cdb, VERIFY16_CMDLEN,
+                                 false, sizeof(b), b));
         if ((vb > 3) && bytchk && data_out && (data_out_len > 0)) {
             k = data_out_len > 4104 ? 4104 : data_out_len;
             pr2ws("    data_out buffer%s\n",
@@ -1716,13 +1736,13 @@ sg_ll_ata_pt(int sg_fd, const uint8_t * cdbp, int cdb_len,
         slen = sizeof(sense_b);
     }
     if (vb) {
-        pr2ws("    %s cdb: ", cnamep);
         if (cdb_len < 32) {
-            for (k = 0; k < cdb_len; ++k)
-                pr2ws("%02x ", apt_cdb[k]);
-            pr2ws("\n");
+            char d[128];
+
+            pr2ws("    %s cdb: %s\n", cnamep,
+                  sg_get_command_str(apt_cdb, cdb_len, false, sizeof(d), d));
         } else {
-            pr2ws("\n");
+            pr2ws("    %s cdb:\n", cnamep);
             hex2stderr(apt_cdb, cdb_len, -1);
         }
     }
@@ -1821,7 +1841,7 @@ sg_ll_read_buffer(int sg_fd, int mode, int buffer_id, int buffer_offset,
                   void * resp, int mx_resp_len, bool noisy, int vb)
 {
     static const char * const cdb_s = "read buffer(10)";
-    int res, k, ret, s_cat;
+    int res, ret, s_cat;
     uint8_t rbuf_cdb[READ_BUFFER_CMDLEN] =
         {READ_BUFFER_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -1832,10 +1852,11 @@ sg_ll_read_buffer(int sg_fd, int mode, int buffer_id, int buffer_offset,
     sg_put_unaligned_be24((uint32_t)buffer_offset, rbuf_cdb + 3);
     sg_put_unaligned_be24((uint32_t)mx_resp_len, rbuf_cdb + 6);
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < READ_BUFFER_CMDLEN; ++k)
-            pr2ws("%02x ", rbuf_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(rbuf_cdb, READ_BUFFER_CMDLEN,
+                                 false, sizeof(b), b));
     }
 
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
@@ -1882,7 +1903,7 @@ sg_ll_write_buffer(int sg_fd, int mode, int buffer_id, int buffer_offset,
                    void * paramp, int param_len, bool noisy, int vb)
 {
     static const char * const cdb_s = "write buffer";
-    int k, res, ret, s_cat;
+    int res, ret, s_cat;
     uint8_t wbuf_cdb[WRITE_BUFFER_CMDLEN] =
         {WRITE_BUFFER_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -1893,10 +1914,11 @@ sg_ll_write_buffer(int sg_fd, int mode, int buffer_id, int buffer_offset,
     sg_put_unaligned_be24((uint32_t)buffer_offset, wbuf_cdb + 3);
     sg_put_unaligned_be24((uint32_t)param_len, wbuf_cdb + 6);
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < WRITE_BUFFER_CMDLEN; ++k)
-            pr2ws("%02x ", wbuf_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(wbuf_cdb, WRITE_BUFFER_CMDLEN,
+                                 false, sizeof(b), b));
         if ((vb > 1) && paramp && param_len) {
             pr2ws("    %s parameter list", cdb_s);
             if (2 == vb) {
@@ -1949,7 +1971,7 @@ sg_ll_write_buffer_v2(int sg_fd, int mode, int m_specific, int buffer_id,
                       uint32_t param_len, int timeout_secs, bool noisy,
                       int vb)
 {
-    int k, res, ret, s_cat;
+    int res, ret, s_cat;
     uint8_t wbuf_cdb[WRITE_BUFFER_CMDLEN] =
         {WRITE_BUFFER_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -1969,10 +1991,11 @@ sg_ll_write_buffer_v2(int sg_fd, int mode, int m_specific, int buffer_id,
     sg_put_unaligned_be24(buffer_offset, wbuf_cdb + 3);
     sg_put_unaligned_be24(param_len, wbuf_cdb + 6);
     if (vb) {
-        pr2ws("    Write buffer cdb: ");
-        for (k = 0; k < WRITE_BUFFER_CMDLEN; ++k)
-            pr2ws("%02x ", wbuf_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    Write buffer cdb: %s\n",
+              sg_get_command_str(wbuf_cdb, WRITE_BUFFER_CMDLEN,
+                                 false, sizeof(b), b));
         if ((vb > 1) && paramp && param_len) {
             pr2ws("    Write buffer parameter list%s:\n",
                   ((param_len > 256) ? " (first 256 bytes)" : ""));
@@ -2029,7 +2052,7 @@ sg_ll_unmap_v2(int sg_fd, bool anchor, int group_num, int timeout_secs,
                void * paramp, int param_len, bool noisy, int vb)
 {
     static const char * const cdb_s = "unmap";
-    int k, res, ret, s_cat, tmout;
+    int res, ret, s_cat, tmout;
     uint8_t u_cdb[UNMAP_CMDLEN] =
                          {UNMAP_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -2041,10 +2064,11 @@ sg_ll_unmap_v2(int sg_fd, bool anchor, int group_num, int timeout_secs,
     u_cdb[6] = group_num & 0x1f;
     sg_put_unaligned_be16((uint16_t)param_len, u_cdb + 7);
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < UNMAP_CMDLEN; ++k)
-            pr2ws("%02x ", u_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(u_cdb, UNMAP_CMDLEN,
+                                 false, sizeof(b), b));
         if ((vb > 1) && paramp && param_len) {
             pr2ws("    %s parameter list:\n", cdb_s);
             hex2stderr((const uint8_t *)paramp, param_len, -1);
@@ -2083,17 +2107,18 @@ sg_ll_read_block_limits(int sg_fd, void * resp, int mx_resp_len,
                         bool noisy, int vb)
 {
     static const char * const cdb_s = "read block limits";
-    int k, ret, res, s_cat;
+    int ret, res, s_cat;
     uint8_t rl_cdb[READ_BLOCK_LIMITS_CMDLEN] =
       {READ_BLOCK_LIMITS_CMD, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
     struct sg_pt_base * ptvp;
 
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < READ_BLOCK_LIMITS_CMDLEN; ++k)
-            pr2ws("%02x ", rl_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(rl_cdb, READ_BLOCK_LIMITS_CMDLEN,
+                                 false, sizeof(b), b));
     }
 
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
@@ -2140,7 +2165,7 @@ int
 sg_ll_receive_copy_results(int sg_fd, int sa, int list_id, void * resp,
                            int mx_resp_len, bool noisy, int vb)
 {
-    int k, res, ret, s_cat;
+    int res, ret, s_cat;
     uint8_t rcvcopyres_cdb[THIRD_PARTY_COPY_IN_CMDLEN] =
       {THIRD_PARTY_COPY_IN_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -2156,10 +2181,11 @@ sg_ll_receive_copy_results(int sg_fd, int sa, int list_id, void * resp,
     sg_put_unaligned_be32((uint32_t)mx_resp_len, rcvcopyres_cdb + 10);
 
     if (vb) {
-        pr2ws("    %s cdb: ", b);
-        for (k = 0; k < THIRD_PARTY_COPY_IN_CMDLEN; ++k)
-            pr2ws("%02x ", rcvcopyres_cdb[k]);
-        pr2ws("\n");
+        char d[128];
+
+        pr2ws("    %s cdb: %s\n", b,
+              sg_get_command_str(rcvcopyres_cdb, THIRD_PARTY_COPY_IN_CMDLEN,
+                                 false, sizeof(d), d));
     }
 
     if (NULL == ((ptvp = create_pt_obj(b))))
@@ -2199,7 +2225,7 @@ int
 sg_ll_extended_copy(int sg_fd, void * paramp, int param_len, bool noisy,
                     int vb)
 {
-    int k, res, ret, s_cat;
+    int res, ret, s_cat;
     uint8_t xcopy_cdb[THIRD_PARTY_COPY_OUT_CMDLEN] =
       {THIRD_PARTY_COPY_OUT_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -2210,10 +2236,11 @@ sg_ll_extended_copy(int sg_fd, void * paramp, int param_len, bool noisy,
     sg_put_unaligned_be32((uint32_t)param_len, xcopy_cdb + 10);
 
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < THIRD_PARTY_COPY_OUT_CMDLEN; ++k)
-            pr2ws("%02x ", xcopy_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(xcopy_cdb, THIRD_PARTY_COPY_OUT_CMDLEN,
+                                 false, sizeof(b), b));
         if ((vb > 1) && paramp && param_len) {
             pr2ws("    %s parameter list:\n", cdb_s);
             hex2stderr((const uint8_t *)paramp, param_len, -1);
@@ -2255,7 +2282,7 @@ sg_ll_3party_copy_out(int sg_fd, int sa, unsigned int list_id, int group_num,
                       int timeout_secs, void * paramp, int param_len,
                       bool noisy, int vb)
 {
-    int k, res, ret, s_cat, tmout;
+    int res, ret, s_cat, tmout;
     uint8_t xcopy_cdb[THIRD_PARTY_COPY_OUT_CMDLEN] =
       {THIRD_PARTY_COPY_OUT_CMD, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -2286,10 +2313,11 @@ sg_ll_3party_copy_out(int sg_fd, int sa, unsigned int list_id, int group_num,
     tmout = (timeout_secs > 0) ? timeout_secs : DEF_PT_TIMEOUT;
 
     if (vb) {
-        pr2ws("    %s cdb: ", cname);
-        for (k = 0; k < THIRD_PARTY_COPY_OUT_CMDLEN; ++k)
-            pr2ws("%02x ", xcopy_cdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cname,
+              sg_get_command_str(xcopy_cdb, THIRD_PARTY_COPY_OUT_CMDLEN,
+                                 false, sizeof(b), b));
         if ((vb > 1) && paramp && param_len) {
             pr2ws("    %s parameter list:\n", cname);
             hex2stderr((const uint8_t *)paramp, param_len, -1);
@@ -2338,7 +2366,7 @@ sg_ll_pre_fetch_x(int sg_fd, bool do_seek10, bool cdb16, bool immed,
     static const char * const cdb10_name_s = "Pre-fetch(10)";
     static const char * const cdb16_name_s = "Pre-fetch(16)";
     static const char * const cdb_seek_name_s = "Seek(10)";
-    int k, res, s_cat, ret, cdb_len, tmout;
+    int res, s_cat, ret, cdb_len, tmout;
     const char *cdb_s;
     uint8_t preFetchCdb[PRE_FETCH16_CMDLEN]; /* all use longest cdb */
     uint8_t sense_b[SENSE_BUFF_LEN];
@@ -2386,10 +2414,10 @@ sg_ll_pre_fetch_x(int sg_fd, bool do_seek10, bool cdb16, bool immed,
     }
     tmout = (timeout_secs > 0) ? timeout_secs : DEF_PT_TIMEOUT;
     if (vb) {
-        pr2ws("    %s cdb: ", cdb_s);
-        for (k = 0; k < cdb_len; ++k)
-            pr2ws("%02x ", preFetchCdb[k]);
-        pr2ws("\n");
+        char b[128];
+
+        pr2ws("    %s cdb: %s\n", cdb_s,
+              sg_get_command_str(preFetchCdb, cdb_len, false, sizeof(b), b));
     }
     if (NULL == ((ptvp = create_pt_obj(cdb_s))))
         return -1;
diff --git a/lib/sg_lib.c b/lib/sg_lib.c
index eb74aad..43a2ebb 100644
--- a/lib/sg_lib.c
+++ b/lib/sg_lib.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999-2019 Douglas Gilbert.
+ * Copyright (c) 1999-2020 Douglas Gilbert.
  * All rights reserved.
  * Use of this source code is governed by a BSD-style
  * license that can be found in the BSD_LICENSE file.
@@ -41,6 +41,9 @@
 #include <inttypes.h>
 #include <errno.h>
 #include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -154,25 +157,78 @@ sg_set_warnings_strm(FILE * warnings_strm)
     sg_warnings_strm = warnings_strm;
 }
 
+/* Take care to minimize printf() parsing delays when printing commands */
+static char bin2hexascii[] = {'0', '1', '2', '3', '4', '5', '6', '7',
+                              '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
+
+
+/* Given a SCSI command pointed to by cdbp of sz bytes this function forms
+ * a SCSI command in ASCII surrounded by square brackets in 'b'. 'b' is at
+ * least blen bytes long. If cmd_name is true then the command is prefixed
+ * by its SCSI command name (e.g.  "VERIFY(10) [2f ...]". The command is
+ * shown as spaced separated pairs of hexadecimal digits (i.e. 0-9, a-f).
+ * Each pair represents byte. The leftmost pair of digits is cdbp[0] . If
+ * sz <= 0 then this function tries to guess the length of the command. */
+char *
+sg_get_command_str(const uint8_t * cdbp, int sz, bool cmd_name, int blen,
+                   char * b)
+{
+    int k, j, jj;
+
+    if ((cdbp == NULL) || (b == NULL) || (blen < 1))
+        return b;
+    if (cmd_name && (blen > 16)) {
+        sg_get_command_name(cdbp, 0, blen, b);
+        j = (int)strlen(b);
+        if (j < (blen - 1))
+            b[j++] = ' ';
+    } else
+        j = 0;
+    if (j >= blen)
+        goto fini;
+    b[j++] = '[';
+    if (j >= blen)
+        goto fini;
+    if (sz <= 0) {
+        if (SG_VARIABLE_LENGTH_CMD == cdbp[0])
+            sz = cdbp[7] + 8;
+        else
+            sz = sg_get_command_size(cdbp[0]);
+    }
+    jj = j;
+    for (k = 0; (k < sz) && (j < (blen - 3)); ++k, j += 3, ++cdbp) {
+        b[j] = bin2hexascii[(*cdbp >> 4) & 0xf];
+        b[j + 1] = bin2hexascii[*cdbp & 0xf];
+        b[j + 2] = ' ';
+    }
+    if (j > jj)
+        --j;    /* don't want trailing space before ']' */
+    if (j >= blen)
+        goto fini;
+    b[j++] = ']';
+fini:
+    if (j >= blen)
+        b[blen - 1] = '\0';     /* truncated string */
+    else
+        b[j] = '\0';
+    return b;
+}
+
 #define CMD_NAME_LEN 128
 
 void
-sg_print_command(const uint8_t * command)
+sg_print_command_len(const uint8_t * cdbp, int sz)
 {
-    int k, sz;
     char buff[CMD_NAME_LEN];
 
-    sg_get_command_name(command, 0, CMD_NAME_LEN, buff);
-    buff[CMD_NAME_LEN - 1] = '\0';
+    sg_get_command_str(cdbp, sz, true, sizeof(buff), buff);
+    pr2ws("%s\n", buff);
+}
 
-    pr2ws("%s [", buff);
-    if (SG_VARIABLE_LENGTH_CMD == command[0])
-        sz = command[7] + 8;
-    else
-        sz = sg_get_command_size(command[0]);
-    for (k = 0; k < sz; ++k)
-        pr2ws("%02x ", command[k]);
-    pr2ws("]\n");
+void
+sg_print_command(const uint8_t * cdbp)
+{
+    sg_print_command_len(cdbp, 0);
 }
 
 /* SCSI Status values */
@@ -547,7 +603,7 @@ sg_decode_transportid_str(const char * lip, uint8_t * bp, int bplen,
     }
     if (NULL == lip)
         lip = "";
-    bump = TRANSPORT_ID_MIN_LEN; /* should be overwritten in all loop paths */
+    /* bump = TRANSPORT_ID_MIN_LEN; // some old compilers insisted on this */
     for (k = 0, n = 0; bplen > 0; ++k, bp += bump, bplen -= bump) {
         if ((k > 0) && only_one)
             break;
@@ -910,7 +966,7 @@ sg_get_designation_descriptor_str(const char * lip, const uint8_t * ddp,
             break;
         }
         ci_off = 0;
-        if (16 == dlen) {
+        if (16 == dlen) {       /* first 8 bytes are 'Identifier Extension' */
             ci_off = 8;
             id_ext = sg_get_unaligned_be64(ip);
             n += sg_scnpr(b + n, blen - n, "%s      Identifier extension: 0x%"
@@ -1875,9 +1931,6 @@ sg_get_sense_str(const char * lip, const uint8_t * sbp, int sb_len,
             sg_scnpr(b + r, blen - r, "%s  lba=0x%x\n", lip,
                      sg_get_unaligned_be24(sbp + 1) & 0x1fffff);
         n += sg_scnpr(cbp + n, cblen - n, "%s\n", b);
-        len = sb_len;
-        if (len > 32)
-            len = 32;   /* trim in case there is a lot of rubbish */
     }
 check_raw:
     if (raw_sinfo) {
@@ -2078,6 +2131,8 @@ sg_scsi_normalize_sense(const uint8_t * sbp, int sb_len,
                 sshp->ascq = sbp[3];
             if (sb_len > 7)
                 sshp->additional_length = sbp[7];
+            sshp->byte4 = sbp[4];       /* bit 7: SDAT_OVFL bit */
+            /* sbp[5] and sbp[6] reserved for descriptor format */
         } else {                              /* fixed format */
             if (sb_len > 2)
                 sshp->sense_key = (0xf & sbp[2]);
@@ -2088,6 +2143,11 @@ sg_scsi_normalize_sense(const uint8_t * sbp, int sb_len,
                 if (sb_len > 13)
                     sshp->ascq = sbp[13];
             }
+            if (sb_len > 6) {   /* lower 3 bytes of INFO field */
+                sshp->byte4 = sbp[4];
+                sshp->byte5 = sbp[5];
+                sshp->byte6 = sbp[6];
+            }
         }
     }
     return true;
@@ -2152,20 +2212,17 @@ sg_get_command_size(uint8_t opcode)
     switch ((opcode >> 5) & 0x7) {
     case 0:
         return 6;
-    case 1: case 2: case 6: case 7:
-        return 10;
     case 3: case 5:
         return 12;
-        break;
     case 4:
         return 16;
-    default:
+    default:        /* 1, 2, 6, 7 */
         return 10;
     }
 }
 
 void
-sg_get_command_name(const uint8_t * cmdp, int peri_type, int buff_len,
+sg_get_command_name(const uint8_t * cdbp, int peri_type, int buff_len,
                     char * buff)
 {
     int service_action;
@@ -2176,13 +2233,13 @@ sg_get_command_name(const uint8_t * cmdp, int peri_type, int buff_len,
         buff[0] = '\0';
         return;
     }
-    if (NULL == cmdp) {
+    if (NULL == cdbp) {
         sg_scnpr(buff, buff_len, "%s", "<null> command pointer");
         return;
     }
-    service_action = (SG_VARIABLE_LENGTH_CMD == cmdp[0]) ?
-                     sg_get_unaligned_be16(cmdp + 8) : (cmdp[1] & 0x1f);
-    sg_get_opcode_sa_name(cmdp[0], service_action, peri_type, buff_len, buff);
+    service_action = (SG_VARIABLE_LENGTH_CMD == cdbp[0]) ?
+                     sg_get_unaligned_be16(cdbp + 8) : (cdbp[1] & 0x1f);
+    sg_get_opcode_sa_name(cdbp[0], service_action, peri_type, buff_len, buff);
 }
 
 struct op_code2sa_t {
@@ -2296,9 +2353,6 @@ sg_get_opcode_name(uint8_t cmd_byte0, int peri_type, int buff_len,
     case 7:
         sg_scnpr(buff, buff_len, "Vendor specific [0x%x]", (int)cmd_byte0);
         break;
-    default:
-        sg_scnpr(buff, buff_len, "Opcode=0x%x", (int)cmd_byte0);
-        break;
     }
 }
 
@@ -2614,6 +2668,7 @@ sg_nvme_status2scsi(uint16_t sct_sc, uint8_t * status_p, uint8_t * sk_p,
         return false;
     } else if (ind >= k)
         return false;
+
     mp = sg_lib_scsi_status_sense_arr + ind;
     if (status_p)
         *status_p = mp->t1;
@@ -3055,18 +3110,24 @@ dWordHex(const uint16_t* words, int num, int no_ascii, bool swapb)
         printf("%.76s\n", buff);
 }
 
-/* If the number in 'buf' can be decoded or the multiplier is unknown
+/* If the number in 'buf' can not be decoded or the multiplier is unknown
  * then -1 is returned. Accepts a hex prefix (0x or 0X) or a decimal
  * multiplier suffix (as per GNU's dd (since 2002: SI and IEC 60027-2)).
  * Main (SI) multipliers supported: K, M, G. Ignore leading spaces and
- * tabs; accept comma, hyphen, space, tab and hash as terminator. */
+ * tabs; accept comma, hyphen, space, tab and hash as terminator.
+ * Handles zero and positive values up to 2**31-1 .
+ * Experimental: left argument (must in with hexadecimal digit) added
+ * to, or multiplied, by right argument. No embedded spaces.
+ * Examples: '3+1k' (evaluates to 1027) and '0x34+1m'. */
 int
 sg_get_num(const char * buf)
 {
+    bool is_hex = false;
     int res, num, n, len;
     unsigned int unum;
     char * cp;
     const char * b;
+    const char * b2p;
     char c = 'c';
     char c2 = '\0';     /* keep static checker happy */
     char c3 = '\0';     /* keep static checker happy */
@@ -3093,24 +3154,35 @@ sg_get_num(const char * buf)
         b = lb;
     } else
         b = buf;
+
+    b2p = b;
     if (('0' == b[0]) && (('x' == b[1]) || ('X' == b[1]))) {
-        res = sscanf(b + 2, "%x", &unum);
+        res = sscanf(b + 2, "%x%c", &unum, &c);
         num = unum;
+        is_hex = true;
+        b2p = b + 2;
     } else if ('H' == toupper((int)b[len - 1])) {
         res = sscanf(b, "%x", &unum);
         num = unum;
     } else
         res = sscanf(b, "%d%c%c%c", &num, &c, &c2, &c3);
+
     if (res < 1)
-        return -1LL;
+        return -1;
     else if (1 == res)
         return num;
     else {
+        c = toupper((int)c);
+        if (is_hex) {
+            if (! ((c == '+') || (c == 'X')))
+                return -1;
+        }
         if (res > 2)
             c2 = toupper((int)c2);
         if (res > 3)
             c3 = toupper((int)c3);
-        switch (toupper((int)c)) {
+
+        switch (c) {
         case 'C':
             return num;
         case 'W':
@@ -3141,16 +3213,26 @@ sg_get_num(const char * buf)
             if (('I' == c2) && (4 == res) && ('B' == c3))
                 return num * 1073741824;
             return -1;
-        case 'X':
-            cp = (char *)strchr(b, 'x');
+        case 'X':       /* experimental: multiplication */
+            /* left argument must end with hexadecimal digit */
+            cp = (char *)strchr(b2p, 'x');
             if (NULL == cp)
-                cp = (char *)strchr(b, 'X');
+                cp = (char *)strchr(b2p, 'X');
             if (cp) {
                 n = sg_get_num(cp + 1);
                 if (-1 != n)
                     return num * n;
             }
             return -1;
+        case '+':       /* experimental: addition */
+            /* left argument must end with hexadecimal digit */
+            cp = (char *)strchr(b2p, '+');
+            if (cp) {
+                n = sg_get_num(cp + 1);
+                if (-1 != n)
+                    return num + n;
+            }
+            return -1;
         default:
             pr2ws("unrecognized multiplier\n");
             return -1;
@@ -3190,19 +3272,25 @@ sg_get_num_nomult(const char * buf)
         return -1;
 }
 
-/* If the number in 'buf' can be decoded or the multiplier is unknown
- * then -1LL is returned. Accepts a hex prefix (0x or 0X) or a decimal
- * multiplier suffix (as per GNU's dd (since 2002: SI and IEC 60027-2)).
- * Main (SI) multipliers supported: K, M, G, T, P. Ignore leading spaces
- * and tabs; accept comma, hyphen, space, tab and hash as terminator. */
+/* If the number in 'buf' can not be decoded or the multiplier is unknown
+ * then -1LL is returned. Accepts a hex prefix (0x or 0X), hex suffix
+ * (h or H), or a decimal multiplier suffix (as per GNU's dd (since 2002:
+ * SI and IEC 60027-2)).  Main (SI) multipliers supported: K, M, G, T, P
+ * and E. Ignore leading spaces and tabs; accept comma, hyphen, space, tab
+ * and hash as terminator. Handles zero and positive values up to 2**63-1 .
+ * Experimental: left argument (must in with hexadecimal digit) added
+ * to, or multiplied by right argument. No embedded spaces.
+ * Examples: '3+1k' (evaluates to 1027) and '0x34+1m'. */
 int64_t
 sg_get_llnum(const char * buf)
 {
+    bool is_hex = false;
     int res, len, n;
     int64_t num, ll;
     uint64_t unum;
     char * cp;
     const char * b;
+    const char * b2p;
     char c = 'c';
     char c2 = '\0';     /* keep static checker happy */
     char c3 = '\0';     /* keep static checker happy */
@@ -3229,63 +3317,74 @@ sg_get_llnum(const char * buf)
         b = lb;
     } else
         b = buf;
+
+    b2p = b;
     if (('0' == b[0]) && (('x' == b[1]) || ('X' == b[1]))) {
-        res = sscanf(b + 2, "%" SCNx64 , &unum);
+        res = sscanf(b + 2, "%" SCNx64 "%c", &unum, &c);
         num = unum;
+        is_hex = true;
+        b2p = b + 2;
     } else if ('H' == toupper((int)b[len - 1])) {
         res = sscanf(b, "%" SCNx64 , &unum);
         num = unum;
     } else
         res = sscanf(b, "%" SCNd64 "%c%c%c", &num, &c, &c2, &c3);
+
     if (res < 1)
         return -1LL;
     else if (1 == res)
         return num;
     else {
+        c = toupper((int)c);
+        if (is_hex) {
+            if (! ((c == '+') || (c == 'X')))
+                return -1;
+        }
         if (res > 2)
             c2 = toupper((int)c2);
         if (res > 3)
             c3 = toupper((int)c3);
-        switch (toupper((int)c)) {
+
+        switch (c) {
         case 'C':
             return num;
         case 'W':
             return num * 2;
         case 'B':
             return num * 512;
-        case 'K':
+        case 'K':       /* kilo or kibi */
             if (2 == res)
                 return num * 1024;
             if (('B' == c2) || ('D' == c2))
                 return num * 1000;
             if (('I' == c2) && (4 == res) && ('B' == c3))
-                return num * 1024;
+                return num * 1024;      /* KiB */
             return -1LL;
-        case 'M':
+        case 'M':       /* mega or mebi */
             if (2 == res)
-                return num * 1048576;
+                return num * 1048576;   /* M */
             if (('B' == c2) || ('D' == c2))
-                return num * 1000000;
+                return num * 1000000;   /* MB */
             if (('I' == c2) && (4 == res) && ('B' == c3))
-                return num * 1048576;
+                return num * 1048576;   /* MiB */
             return -1LL;
-        case 'G':
+        case 'G':       /* giga or gibi */
             if (2 == res)
-                return num * 1073741824;
+                return num * 1073741824;        /* G */
             if (('B' == c2) || ('D' == c2))
-                return num * 1000000000;
+                return num * 1000000000;        /* GB */
             if (('I' == c2) && (4 == res) && ('B' == c3))
-                return num * 1073741824;
+                return num * 1073741824;        /* GiB */
             return -1LL;
-        case 'T':
+        case 'T':       /* tera or tebi */
             if (2 == res)
-                return num * 1099511627776LL;
+                return num * 1099511627776LL;   /* T */
             if (('B' == c2) || ('D' == c2))
-                return num * 1000000000000LL;
+                return num * 1000000000000LL;   /* TB */
             if (('I' == c2) && (4 == res) && ('B' == c3))
-                return num * 1099511627776LL;
+                return num * 1099511627776LL;   /* TiB */
             return -1LL;
-        case 'P':
+        case 'P':       /* peta or pebi */
             if (2 == res)
                 return num * 1099511627776LL * 1024;
             if (('B' == c2) || ('D' == c2))
@@ -3293,16 +3392,32 @@ sg_get_llnum(const char * buf)
             if (('I' == c2) && (4 == res) && ('B' == c3))
                 return num * 1099511627776LL * 1024;
             return -1LL;
-        case 'X':
-            cp = (char *)strchr(b, 'x');
+        case 'E':       /* exa or exbi */
+            if (2 == res)
+                return num * 1099511627776LL * 1024 * 1024;
+            if (('B' == c2) || ('D' == c2))
+                return num * 1000000000000LL * 1000 * 1000;
+            if (('I' == c2) && (4 == res) && ('B' == c3))
+                return num * 1099511627776LL * 1024 * 1024;
+            return -1LL;
+        case 'X':       /* experimental: decimal (left arg) multiplication */
+            cp = (char *)strchr(b2p, 'x');
             if (NULL == cp)
-                cp = (char *)strchr(b, 'X');
+                cp = (char *)strchr(b2p, 'X');
             if (cp) {
                 ll = sg_get_llnum(cp + 1);
                 if (-1LL != ll)
                     return num * ll;
             }
             return -1LL;
+        case '+':       /* experimental: decimal (left arg) addition */
+            cp = (char *)strchr(b2p, '+');
+            if (cp) {
+                ll = sg_get_llnum(cp + 1);
+                if (-1LL != ll)
+                    return num + ll;
+            }
+            return -1LL;
         default:
             pr2ws("unrecognized multiplier\n");
             return -1LL;
@@ -3336,6 +3451,217 @@ sg_get_llnum_nomult(const char * buf)
     return (1 == res) ? num : -1;
 }
 
+/* Read ASCII hex bytes or binary from fname (a file named '-' taken as
+ * stdin). If reading ASCII hex then there should be either one entry per
+ * line or a comma, space or tab separated list of bytes. If no_space is
+ * set then a string of ACSII hex digits is expected, 2 per byte. Everything
+ * from and including a '#' on a line is ignored. Returns 0 if ok, or an
+ * error code. If the error code is SG_LIB_LBA_OUT_OF_RANGE then mp_arr
+ * would be exceeded and both mp_arr and mp_arr_len are written to. */
+int
+sg_f2hex_arr(const char * fname, bool as_binary, bool no_space,
+             uint8_t * mp_arr, int * mp_arr_len, int max_arr_len)
+{
+    bool has_stdin, split_line;
+    int fn_len, in_len, k, j, m, fd, err;
+    int off = 0;
+    int ret = 0;
+    unsigned int h;
+    const char * lcp;
+    FILE * fp;
+    struct stat a_stat;
+    char line[512];
+    char carry_over[4];
+
+    if ((NULL == fname) || (NULL == mp_arr) || (NULL == mp_arr_len))
+        return SG_LIB_LOGIC_ERROR;
+    fn_len = strlen(fname);
+    if (0 == fn_len)
+        return SG_LIB_SYNTAX_ERROR;
+    has_stdin = ((1 == fn_len) && ('-' == fname[0]));   /* read from stdin */
+    if (as_binary) {
+        if (has_stdin)
+            fd = STDIN_FILENO;
+        else {
+            fd = open(fname, O_RDONLY);
+            if (fd < 0) {
+                err = errno;
+                pr2serr("unable to open binary file %s: %s\n", fname,
+                         safe_strerror(err));
+                return sg_convert_errno(err);
+            }
+        }
+        k = read(fd, mp_arr, max_arr_len);
+        if (k <= 0) {
+            if (0 == k) {
+                ret = SG_LIB_SYNTAX_ERROR;
+                pr2serr("read 0 bytes from binary file %s\n", fname);
+            } else {
+                ret = sg_convert_errno(errno);
+                pr2serr("read from binary file %s: %s\n", fname,
+                        safe_strerror(errno));
+            }
+            goto bin_fini;
+        }
+        if ((0 == fstat(fd, &a_stat)) && S_ISFIFO(a_stat.st_mode)) {
+            /* pipe; keep reading till error or 0 read */
+            while (k < max_arr_len) {
+                m = read(fd, mp_arr + k, max_arr_len - k);
+                if (0 == m)
+                   break;
+                if (m < 0) {
+                    err = errno;
+                    pr2serr("read from binary pipe %s: %s\n", fname,
+                            safe_strerror(err));
+                    ret = sg_convert_errno(err);
+                    goto bin_fini;
+                }
+                k += m;
+            }
+        }
+        *mp_arr_len = k;
+bin_fini:
+        if (! has_stdin)
+            close(fd);
+        return ret;
+    }
+
+    /* So read the file as ASCII hex */
+    if (has_stdin)
+        fp = stdin;
+    else {
+        fp = fopen(fname, "r");
+        if (NULL == fp) {
+            err = errno;
+            pr2serr("Unable to open %s for reading: %s\n", fname,
+                    safe_strerror(err));
+            ret = sg_convert_errno(err);
+            goto fini;
+        }
+    }
+
+    carry_over[0] = 0;
+    for (j = 0; j < 512; ++j) {
+        if (NULL == fgets(line, sizeof(line), fp))
+            break;
+        in_len = strlen(line);
+        if (in_len > 0) {
+            if ('\n' == line[in_len - 1]) {
+                --in_len;
+                line[in_len] = '\0';
+                split_line = false;
+            } else
+                split_line = true;
+        }
+        if (in_len < 1) {
+            carry_over[0] = 0;
+            continue;
+        }
+        if (carry_over[0]) {
+            if (isxdigit(line[0])) {
+                carry_over[1] = line[0];
+                carry_over[2] = '\0';
+                if (1 == sscanf(carry_over, "%4x", &h))
+                    mp_arr[off - 1] = h;       /* back up and overwrite */
+                else {
+                    pr2serr("%s: carry_over error ['%s'] around line %d\n",
+                            __func__, carry_over, j + 1);
+                    ret = SG_LIB_SYNTAX_ERROR;
+                    goto fini;
+                }
+                lcp = line + 1;
+                --in_len;
+            } else
+                lcp = line;
+            carry_over[0] = 0;
+        } else
+            lcp = line;
+
+        m = strspn(lcp, " \t");
+        if (m == in_len)
+            continue;
+        lcp += m;
+        in_len -= m;
+        if ('#' == *lcp)
+            continue;
+        k = strspn(lcp, "0123456789aAbBcCdDeEfF ,\t");
+        if ((k < in_len) && ('#' != lcp[k]) && ('\r' != lcp[k])) {
+            pr2serr("%s: syntax error at line %d, pos %d\n", __func__,
+                    j + 1, m + k + 1);
+            ret = SG_LIB_SYNTAX_ERROR;
+            goto fini;
+        }
+        if (no_space) {
+            for (k = 0; isxdigit(*lcp) && isxdigit(*(lcp + 1));
+                 ++k, lcp += 2) {
+                if (1 != sscanf(lcp, "%2x", &h)) {
+                    pr2serr("%s: bad hex number in line %d, pos %d\n",
+                            __func__, j + 1, (int)(lcp - line + 1));
+                    ret = SG_LIB_SYNTAX_ERROR;
+                    goto fini;
+                }
+                if ((off + k) >= max_arr_len) {
+                    pr2serr("%s: array length exceeded\n", __func__);
+                    *mp_arr_len = max_arr_len;
+                    ret = SG_LIB_LBA_OUT_OF_RANGE;
+                    goto fini;
+                }
+                mp_arr[off + k] = h;
+            }
+            if (isxdigit(*lcp) && (! isxdigit(*(lcp + 1))))
+                carry_over[0] = *lcp;
+            off += k;
+        } else {
+            for (k = 0; k < 1024; ++k) {
+                if (1 == sscanf(lcp, "%10x", &h)) {
+                    if (h > 0xff) {
+                        pr2serr("%s: hex number larger than 0xff in line "
+                                "%d, pos %d\n", __func__, j + 1,
+                                (int)(lcp - line + 1));
+                        ret = SG_LIB_SYNTAX_ERROR;
+                        goto fini;
+                    }
+                    if (split_line && (1 == strlen(lcp))) {
+                        /* single trailing hex digit might be a split pair */
+                        carry_over[0] = *lcp;
+                    }
+                    if ((off + k) >= max_arr_len) {
+                        pr2serr("%s: array length exceeded\n", __func__);
+                        ret = SG_LIB_LBA_OUT_OF_RANGE;
+                        *mp_arr_len = max_arr_len;
+                        goto fini;
+                    }
+                    mp_arr[off + k] = h;
+                    lcp = strpbrk(lcp, " ,\t");
+                    if (NULL == lcp)
+                        break;
+                    lcp += strspn(lcp, " ,\t");
+                    if ('\0' == *lcp)
+                        break;
+                } else {
+                    if (('#' == *lcp) || ('\r' == *lcp)) {
+                        --k;
+                        break;
+                    }
+                    pr2serr("%s: error in line %d, at pos %d\n", __func__,
+                            j + 1, (int)(lcp - line + 1));
+                    ret = SG_LIB_SYNTAX_ERROR;
+                    goto fini;
+                }
+            }
+            off += (k + 1);
+        }
+    }
+    *mp_arr_len = off;
+    if (stdin != fp)
+        fclose(fp);
+    return 0;
+fini:
+    if (stdin != fp)
+        fclose(fp);
+    return ret;
+}
+
 /* Extract character sequence from ATA words as in the model string
  * in a IDENTIFY DEVICE response. Returns number of characters
  * written to 'ochars' before 0 character is found or 'num' words
diff --git a/lib/sg_lib_data.c b/lib/sg_lib_data.c
index fd4176b..6c0326c 100644
--- a/lib/sg_lib_data.c
+++ b/lib/sg_lib_data.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007-2019 Douglas Gilbert.
+ * Copyright (c) 2007-2020 Douglas Gilbert.
  * All rights reserved.
  * Use of this source code is governed by a BSD-style
  * license that can be found in the BSD_LICENSE file.
@@ -19,7 +19,8 @@
 #include "sg_lib_data.h"
 
 
-const char * sg_lib_version_str = "2.61 20190113";/* spc5r20, sbc4r15 */
+const char * sg_lib_version_str = "2.72 20200125";
+/* spc5r22, sbc4r17, zbc2r04 */
 
 
 /* indexed by pdt; those that map to own index do not decay */
@@ -103,7 +104,8 @@ struct sg_lib_value_name_t sg_lib_normal_opcodes[] = {
     {0x37, 0, "Read defect data(10)"},
                         /* SBC-3 r31 recommends Read defect data(12) */
     {0x37, PDT_MCHANGER, "Initialize element status with range"},
-    {0x38, 0, "Medium scan"},
+    {0x38, 0, "Format with preset scan"},
+    {0x38, PDT_OCRW, "Medium scan"},
     {0x39, 0, "Compare"},               /* obsolete in SPC-4 r11 */
     {0x3a, 0, "Copy and verify"},       /* obsolete in SPC-4 r11 */
     {0x3b, 0, "Write buffer"},
@@ -529,6 +531,10 @@ struct sg_lib_value_name_t sg_lib_zoning_out_arr[] = {
 /* Zoning in [0x95] service actions */
 struct sg_lib_value_name_t sg_lib_zoning_in_arr[] = {
     {0x0, PDT_ZBC, "Report zones"},
+    {0x6, PDT_ZBC, "Report realms"},            /* zbc2r04 */
+    {0x7, PDT_ZBC, "Report zone domains"},      /* zbc2r04 */
+    {0x8, PDT_ZBC, "Zone activate"},            /* zbc2r04 */
+    {0x9, PDT_ZBC, "Zone query"},               /* zbc2r04 */
     {0xffff, 0, NULL},
 };
 
@@ -628,7 +634,7 @@ struct sg_lib_value_name_t sg_lib_read_attr_arr[] = {
 
 /* A conveniently formatted list of SCSI ASC/ASCQ codes and their
  * corresponding text can be found at: www.t10.org/lists/asc-num.txt
- * The following should match asc-num.txt dated 20150423 */
+ * The following should match asc-num.txt dated 20191014 */
 
 #ifdef SG_SCSI_STRINGS
 struct sg_lib_asc_ascq_range_t sg_lib_asc_ascq_range[] =
@@ -718,6 +724,7 @@ struct sg_lib_asc_ascq_t sg_lib_asc_ascq[] =
     {0x04,0x21,"Logical unit not ready, hard reset required"},
     {0x04,0x22,"Logical unit not ready, power cycle required"},
     {0x04,0x23,"Logical unit not ready, affiliation required"},
+    {0x04,0x24,"Depopulation in progress"},             /* spc5r15 */
     {0x05,0x00,"Logical unit does not respond to selection"},
     {0x06,0x00,"No reference position found"},
     {0x07,0x00,"Multiple peripheral devices selected"},
@@ -753,6 +760,7 @@ struct sg_lib_asc_ascq_t sg_lib_asc_ascq[] =
     {0x0B,0x11,"Warning - low operating humidity limit exceeded"},
     {0x0B,0x12,"Warning - microcode security at risk"},
     {0x0B,0x13,"Warning - microcode digital signature validation failure"},
+    {0x0B,0x14,"Warning - physical element status change"},     /* spc5r15 */
     {0x0C,0x00,"Write error"},
     {0x0C,0x01,"Write error - recovered with auto reallocation"},
     {0x0C,0x02,"Write error - auto reallocation failed"},
@@ -1026,6 +1034,7 @@ struct sg_lib_asc_ascq_t sg_lib_asc_ascq[] =
     {0x31,0x01,"Format command failed"},
     {0x31,0x02,"Zoned formatting failed due to spare linking"},
     {0x31,0x03,"Sanitize command failed"},
+    {0x31,0x04,"Depopulation failed"},          /* spc5r15 */
     {0x32,0x00,"No defect spare location available"},
     {0x32,0x01,"Defect list update failure"},
     {0x33,0x00,"Tape length error"},
@@ -1498,7 +1507,7 @@ const char * sg_lib_pdt_strs[32] = {    /* should have 2**5 elements */
 
 const char * sg_lib_transport_proto_strs[] =
 {
-    "Fibre Channel Protocol for SCSI (FCP-4)",
+    "Fibre Channel Protocol for SCSI (FCP-5)",  /* now at fcp5r01 */
     "SCSI Parallel Interface (SPI-5)",  /* obsolete in spc5r01 */
     "Serial Storage Architecture SCSI-3 Protocol (SSA-S3P)",
     "Serial Bus Protocol for IEEE 1394 (SBP-3)",
@@ -1560,6 +1569,7 @@ struct sg_lib_simple_value_name_t sg_lib_nvme_admin_cmd_arr[] =
     {0x81, "Security Send"},
     {0x82, "Security Receive"},
     {0x84, "Sanitize"},                 /* last NVM specific in 1.3a */
+    {0x86, "Get LBA status"},           /* NVM specific, new in 1.4 */
     /* Vendor specific 0xc0 to 0xff */
     {0xffff, NULL},                     /* Sentinel */
 };
@@ -1635,7 +1645,11 @@ struct sg_lib_value_name_t sg_lib_nvme_cmd_status_arr[] =
     {0x1d, 11, "Sanitize in progress"},
     {0x1e,  5, "SGL data block granularity invalid"},
     {0x1f,  5, "Command not supported for queue in CMB"},
+    {0x20,  18, "Namespace is write protected"},        /* NVMe 1.4 */
+    {0x21,  6, "Command interrupted"},                  /* NVMe 1.4 */
+    {0x22,  5, "Transient transport error"},            /* NVMe 1.4 */
 
+    /* 0x80 - 0xbf: I/O command set specific */
     /* Generic command status values, NVM (I/O) Command Set */
     {0x80, 12, "LBA out of range"},
     {0x81,  3, "Capacity exceeded"},
@@ -1680,6 +1694,9 @@ struct sg_lib_value_name_t sg_lib_nvme_cmd_status_arr[] =
     {0x120, 5, "Invalid secondary controller state"},
     {0x121, 5, "Invalid number of controller resources"},
     {0x122, 5, "Invalid resource identifier"},
+    {0x123, 5, "Sanitize prohibited while PM enabled"},         /* NVMe 1.4 */
+    {0x124, 5, "ANA group identifier invalid"},                 /* NVMe 1.4 */
+    {0x125, 5, "ANA attach failed"},                            /* NVMe 1.4 */
 
     /* Command specific status values, Status Code Type (SCT): 1h
      * for NVM (I/O) Command Set */
diff --git a/lib/sg_pt_common.c b/lib/sg_pt_common.c
index 242e477..47e01e1 100644
--- a/lib/sg_pt_common.c
+++ b/lib/sg_pt_common.c
@@ -31,7 +31,7 @@
 #include "sg_pt_nvme.h"
 #endif
 
-static const char * scsi_pt_version_str = "3.11 20190128";
+static const char * scsi_pt_version_str = "3.12 20190612";
 
 
 const char *
diff --git a/lib/sg_pt_linux.c b/lib/sg_pt_linux.c
index 4a570f8..c96c1d1 100644
--- a/lib/sg_pt_linux.c
+++ b/lib/sg_pt_linux.c
@@ -7,7 +7,7 @@
  * SPDX-License-Identifier: BSD-2-Clause
  */
 
-/* sg_pt_linux version 1.46 20190111 */
+/* sg_pt_linux version 1.47 20190612 */
 
 
 #include <stdio.h>
@@ -56,7 +56,10 @@
 #define DEF_TIMEOUT 60000       /* 60,000 millisecs (60 seconds) */
 
 /* sg driver displayed format: [x]xyyzz --> [x]x.[y]y.zz */
-#define SG_LINUX_SG_VER_V4 40000   /* lowest version in which v4 available */
+#define SG_LINUX_SG_VER_V4_BASE 40000   /* lowest sg driver version with
+                                         * v4 interface */
+#define SG_LINUX_SG_VER_V4_FULL 40030   /* lowest version with full v4
+                                         * interface */
 
 static const char * linux_host_bytes[] = {
     "DID_OK", "DID_NO_CONNECT", "DID_BUS_BUSY", "DID_TIME_OUT",
@@ -536,7 +539,7 @@ set_pt_file_handle(struct sg_pt_base * vp, int dev_fd, int verbose)
             if (verbose > 4) {
                 int ver = ptp->sg_version;
 
-                if (ptp->sg_version >= SG_LINUX_SG_VER_V4) {
+                if (ptp->sg_version >= SG_LINUX_SG_VER_V4_BASE) {
 #ifdef IGNORE_LINUX_SGV4
                     pr2ws("%s: sg driver version %d.%02d.%02d but config "
                           "override back to v3\n", __func__, ver / 10000,
@@ -554,7 +557,7 @@ set_pt_file_handle(struct sg_pt_base * vp, int dev_fd, int verbose)
         } else if (ptp->is_sg)
             ptp->sg_version = sg_driver_version_num;
 
-        if (ptp->is_sg && (ptp->sg_version >= SG_LINUX_SG_VER_V4) &&
+        if (ptp->is_sg && (ptp->sg_version >= SG_LINUX_SG_VER_V4_FULL) &&
             getenv("SG3_UTILS_LINUX_NANO")) {
             struct sg_extended_info sei;
             struct sg_extended_info * seip = &sei;
@@ -575,6 +578,11 @@ set_pt_file_handle(struct sg_pt_base * vp, int dev_fd, int verbose)
                     pr2ws("%s: dev_fd=%d, succeeding in setting durations "
                           "to nanoseconds\n", __func__, dev_fd);
             }
+        } else if (ptp->is_sg && (ptp->sg_version >= SG_LINUX_SG_VER_V4_BASE)
+                   && getenv("SG3_UTILS_LINUX_NANO")) {
+            if (verbose > 2)
+                pr2ws("%s: dev_fd=%d, ignored SG3_UTILS_LINUX_NANO\nbecause "
+                      "base version sg version 4 driver\n", __func__, dev_fd);
         }
     } else {
         ptp->is_sg = false;
@@ -1117,7 +1125,7 @@ do_scsi_pt(struct sg_pt_base * vp, int fd, int time_secs, int verbose)
 #ifdef IGNORE_LINUX_SGV4
         return do_scsi_pt_v3(ptp, fd, time_secs, verbose);
 #else
-        if (ptp->sg_version >= SG_LINUX_SG_VER_V4)
+        if (ptp->sg_version >= SG_LINUX_SG_VER_V4_BASE)
             return do_scsi_pt_v4(ptp, fd, time_secs, verbose);
         else
             return do_scsi_pt_v3(ptp, fd, time_secs, verbose);
diff --git a/lib/sg_pt_linux_nvme.c b/lib/sg_pt_linux_nvme.c
index 771dd59..10e176b 100644
--- a/lib/sg_pt_linux_nvme.c
+++ b/lib/sg_pt_linux_nvme.c
@@ -907,11 +907,6 @@ sntl_senddiag(struct sg_pt_linux_scsi * ptp, const uint8_t * cdbp,
             return 0;
         } else
             return 0;     /* nothing to do */
-        if (dout_len > 0) {
-            if (vb)
-                pr2ws("%s: dout given but PF clear\n", __func__);
-            return SCSI_PT_DO_BAD_PARAMS;
-        }
     }
     if (dout_len < 4) {
         if (vb)
